{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BlinkReceipt","text":"<p>BlinkReceipt provides a solution for capturing, extracting and enriching first party data from paper, digital receipts and online purchases. Our features include:</p> <ul> <li>Physical receipt scanning</li> <li>Email Linking to retrieve digital receipts from end user\u2019s email accounts</li> <li>Account Linking to connect to end user\u2019s online retailer accounts to extract purchase data</li> </ul> <p></p> Requirement Version Android Min SDK 23+ (Android 6.0+) Android Compile SDK 36+ Java 17+ Architecture armeabi-v7a, arm64-v8a Camera 720+ GPU"},{"location":"alp_background/","title":"Running in the background","text":"<p>The recommended way of using the Account Linking Android SDK in the background is using WorkManager, which is the recommended solution for persistent work. To start, you have to define a class which will extend from a WorkManager worker. We recommend extending from <code>CoroutineWorker</code> if you\u2019re working with Kotlin, and <code>ListenableWorker</code> if you\u2019re working with Java, as we have to wait until the Account Linking SDK finishes before finishing work.</p> KotlinJava <pre><code>public class AccountLinkingWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params){\n}\n</code></pre> <pre><code>public class AccountLinkingWorker extends ListenableWorker {\n\n    public AccountLinkingWorker(@NonNull Context appContext, @NonNull WorkerParameters params) {\n        super(appContext, params);\n    }\n}\n</code></pre> <p>Then you have to override the <code>doWork</code>/<code>startWork</code> function, in which we need to set the licence keys (if you haven\u2019t set them in the manifest file as described here), initialize the Account Linking SDK, instantiate the <code>AccountLinkingClient</code>, configure it, and call <code>orders</code>.</p> KotlinJava <pre><code>override suspend fun doWork(): Result {\n    //set license keys if you haven't done so in your AndroidManifest.xml\n    BlinkReceiptLinkingSdk.licenseKey = \"&lt;your_account_linking_key&gt;\"\n    BlinkReceiptLinkingSdk.productIntelligenceKey = \"&lt;your_product_intelligence_key&gt;\"\n\n    //initialize the sdk\n    BlinkReceiptLinkingSdk.initialize(applicationContext)\n\n    val client = AccountLinkingClient(applicationContext)\n    //configure the client\n    client.dayCutoff = 14\n\n    val suspendResult = suspendCoroutine { continuation -&gt;\n        client.orders(AMAZON, failure = { retailerId, exception -&gt;\n            //log exception\n            Timber.e(exception)\n            if(exception.code == VERIFICATION_NEEDED) {\n                // if verification is needed, you should attempt to retrieve orders while the app is in the foreground,\n                // and show the exception.view to the end user so he can complete the required verification\n            }\n\n            continuation.resume(Result.failure())\n        }, success = { retailerId, results, remaining, uuid -&gt;\n            if(results != null){\n                //store results in database, API etc.\n            }\n\n            // no remaining orders, so we can complete the session\n            if(remaining == 0){\n                continuation.resume(Result.success())\n            }\n        })\n    }\n\n    return suspendResult\n}\n</code></pre> <pre><code>@NonNull\n@Override\npublic ListenableFuture&lt;Result&gt; startWork() {\n\n    //set license keys if you haven't done so in your AndroidManifest.xml\n    BlinkReceiptLinkingSdk.licenseKey(\"&lt;your_account_linking_licence_key&gt;\");\n    BlinkReceiptLinkingSdk.productIntelligenceKey(\"&lt;your_product_intelligence_key&gt;\");\n\n    //initialize the sdk\n    BlinkReceiptLinkingSdk.initialize(getApplicationContext());\n\n    SettableFuture&lt;Result&gt; future = SettableFuture.create();\n    AccountLinkingClient client = new AccountLinkingClient(this.getApplicationContext());\n    //configure the client\n    client.dayCutoff(14);\n    client.orders(AMAZON, (Integer retailerId, ScanResults results, Integer remaining, String uuid) -&gt; {\n        if (results != null) {\n            //store results in database, API etc.\n        }\n\n        // no remaining orders, so we can complete the session\n        if (remaining == 0) {\n            future.set(Result.success());\n        }\n        return Unit.INSTANCE;\n    }, (Integer retailerId, AccountLinkingException exception) -&gt; {\n        //log exception\n        Timber.e(exception);\n        if (exception.code() == AccountLinkingCodes.VERIFICATION_NEEDED) {\n            // if verification is needed, you should attempt to retrieve orders while the app is in the foreground,\n            // and show the exception.view to the end user so he can complete the required verification\n        }\n\n        future.setException(exception);\n\n        return Unit.INSTANCE;\n    });\n\n    return future;\n}\n</code></pre> <p>After we\u2019re done with the Worker implementation, we need to enqueue its execution. WorkManager enables you to enqueue either one-time or periodic work. Depending on your specific needs, you can enqueue the execution at a specific point in your users journey. Preferably, you should enqueue background work after you\u2019ve successfully verified an account or retrieved orders at least once in the foreground, as additional verification may be required from the end user. Here\u2019s an example on how to enqueue periodic work:</p> KotlinJava <pre><code>val manager = WorkManager.getInstance(requireContext())\nval request = PeriodicWorkRequestBuilder&lt;AccountLinkingWorker&gt;(7, TimeUnit.DAYS)\n//account linking requires a working network connection\n.setConstraints(Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build())\n.build()\n\nmanager.enqueueUniquePeriodicWork(\"AccountLinkingBackgroundWork\", ExistingPeriodicWorkPolicy.UPDATE, request)\n</code></pre> <pre><code>WorkManager manager = WorkManager.getInstance(this);\nPeriodicWorkRequest request = new PeriodicWorkRequest.Builder(AccountLinkingFragment.AccountLinkingWorker.class, 7, TimeUnit.DAYS)\n//account linking requires a working network connection\n.setConstraints(new Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build())\n.build();\nmanager.enqueueUniquePeriodicWork(\"AccountLinkingBackgroundWork\", ExistingPeriodicWorkPolicy.UPDATE, request);\n</code></pre>"},{"location":"alp_error_codes/","title":"Error codes","text":"<p>Codes which are returned via the Account Linking SDK callbacks when calling <code>verify</code> or <code>orders</code>.</p> Name Value Description MISSING_CREDENTIALS 1003 An attempt was made to grab orders or verify but no linked account for the specified retailer was found VERIFICATION_NEEDED 1004 Login encountered a scenario requiring manual user intervention (CAPTCHA, 2FA, etc) JS_INVALID_DATA 1005 The structure of the retailer\u2019s website or data feed that was encountered during parsing was unexpected JS_CORE_LOAD_FAILURE 1007 An unexpected error occurred during login or parsing USER_INPUT_COMPLETED 1008 The user completed the necessarry input after a VERIFICATION_NEEDED code was returned and the WebView was shown PARSING_FAILURE 1050 The structure of the retailer\u2019s website or data feed that was encountered during parsing was unexpected INVALID_CREDENTIALS 1051 Login failed on the retailer\u2019s site due to invalid credentials INTERNAL_ERROR 1009 An unexpected error occurred during login or parsing UNSUPPORTED_RETAILER 1052 This retailer is not currently supported"},{"location":"android_16_migration_guide/","title":"Android 16 (API 36) Migration Guide for BlinkReceipt Android SDK","text":"<p>This guide provides essential steps for updating your app to target Android 16 (API 36) while ensuring continued compatibility with the BlinkReceipt Android SDK.</p> <p>With the release of Android 16, Google has introduced several changes to enhance privacy, security, and user experience. To comply with Google Play\u2019s requirements and leverage the latest platform features, you must update your app\u2019s <code>targetSdkVersion</code> to 36.</p> <p>Our latest SDK version, <code>1.9.13</code>, is fully compatible with Android 16. Please update to this version before proceeding.</p>"},{"location":"android_16_migration_guide/#notes","title":"Notes","text":"<p>Min SDK 23:  Apps running on devices below API 23 can still use your existing app, but they won\u2019t be able to upgrade once the new version ships.</p> <p>Target API 36:  You only need to compile against it; there\u2019s no risk unless our SDK starts using API 36 features (which it doesn\u2019t today).</p> <p>Java 17:  Our upcoming SDK (<code>1.9.13</code>) targets JVM 17, but this won\u2019t break client apps as long as you\u2019re using reasonably up-to-date build tools.</p> <p>React Native:  Android 16 support requires the latest RN version, but that\u2019s separate from our SDK upgrade.</p>"},{"location":"android_16_migration_guide/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, please ensure you have the following:</p> <ol> <li>Update Android Studio to the latest stable version (e.g., Koala \ud83d\udc28 or newer).</li> <li> <p>Update the Android Gradle Plugin to the version recommended for targeting API 36.</p> <ul> <li>See the Android Gradle plugin official documentation to see what required plugin versions you\u2019ll use.</li> </ul> </li> <li> <p>Update our SDK in your <code>build.gradle</code> or <code>build.gradle.kts</code> file: <pre><code>// build.gradle\ndependencies {\n    implementation(platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\"))\n\n    implementation(\"com.microblink.blinkreceipt:blinkreceipt-digital\")\n    implementation(\"com.microblink.blinkreceipt:blinkreceipt-recognizer\")\n    // ...\n}\n</code></pre></p> </li> <li> <p>Change your app\u2019s <code>targetSdkVersion</code> and <code>compileSdkVersion</code> to 36: <pre><code>// build.gradle\nandroid {\n    compileSdk 36\n\n    defaultConfig {\n        targetSdk 36\n        // ...\n    }\n    // ...\n}\n</code></pre></p> </li> </ol>"},{"location":"android_16_migration_guide/#behavioral-changes","title":"Behavioral Changes","text":"<p>These changes affect how your app and our SDK behave when running on an Android 16 device, regardless of targetSdkVersion. However, they are most relevant when you update your target.</p>"},{"location":"android_16_migration_guide/#edge-to-edge-display-enabled-by-default","title":"Edge-to-Edge Display Enabled by Default","text":"<p>What\u2019s changing?</p> <p>To create more immersive user experiences, Android 16 enables edge-to-edge rendering by default for all apps targeting API 36. This means your app\u2019s UI will draw behind the transparent system status and navigation bars.</p> <p>Impact on your app:</p> <p>If you display any of our SDK\u2019s full-screen or large UI components (like [com.microblink.RecognizerCameraView]), they may have interactive elements (like buttons or input fields) that are partially obscured by the system bars, making them difficult for users to tap.</p> <p>Action required:</p> <p>You must handle window insets to prevent UI elements from overlapping with the system bars. Ensure you\u2019ve opted into edge-to-edge.</p> <ul> <li>See official documentation on Behavior changes: Apps targeting Android 16 or higher</li> </ul> <p>This ensures that BlinkReceipt SDK\u2019s UI respects the device\u2019s safe areas while still providing an immersive, edge-to-edge experience.</p>"},{"location":"android_16_migration_guide/#testing-checklist","title":"Testing Checklist","text":"<p>After implementing the changes above, we strongly recommend you test the following scenarios on a device or emulator running Android 16:</p> <ul> <li> <p>\u2705 Test all flows that involve selecting BlinkReceipt SDK Camera or Scan feature. Ensure that it appears and functions correctly.</p> </li> <li> <p>\u2705 Perform regression testing on all core features of your app that integrate with BlinkReceipt Android SDK <code>1.9.13</code>.</p> </li> </ul>"},{"location":"android_16_migration_guide/#get-help","title":"Get Help","text":"<p>If you encounter any issues during migration or have questions about these changes, please do not hesitate to reach out to our support team.</p>"},{"location":"configuring_client_alp/","title":"Configuring the Client","text":"<p>The main and only entry point to using the Account Linking SDK is the <code>AccountLinkingClient</code> class. You can instantiate one by passing an android context to its constructor:</p> KotlinJava <pre><code>val client = AccountLinkingClient(context)\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\n</code></pre> <p>There are also some more options for configuring the client.</p>"},{"location":"configuring_client_alp/#cutoff-day","title":"Cutoff Day","text":"<ol> <li> <p>Setting the <code>dayCutoff</code> property on the <code>AccountLinkingClient</code> instance, i.e.:</p> KotlinJava <pre><code>val client = AccountLinkingClient(context)\nclient.dayCutoff = 14\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\nclient.dayCutoff(14);\n</code></pre> <p>This means that the orders from the last 14 days will be retrieved from the linked account. By default, the <code>dayCutoff</code> is set to 15 days.</p> </li> <li> <p>Setting the <code>dateCutoff</code> property on the <code>AccountLinkingClient</code> instance, i.e.:</p> KotlinJava <pre><code>val client = AccountLinkingClient(context)\nclient.dateCutoff = Date.from(Instant.now().minus(14, ChronoUnit.DAYS))\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\nclient.dateCutoff(Date.from(Instant.now().minus(14, ChronoUnit.DAYS)));\n</code></pre> <p>This will also mean that orders from the last 14 days are retrieved, but you could also set a fixed date. By default, the <code>dateCutoff</code> value is set to <code>null</code>, then the <code>dayCutoff</code> value will be used instead.</p> </li> </ol> <p>The first scrape will attempt to retrieve orders back to the <code>dayCutoff</code> OR <code>dateCutoff</code>. All subsequent scrapes will only go as far back as the last scrape date regardless of whether the first scrape completed.</p> <ul> <li>If the <code>dayCutoff</code> was set to 365 days (OR <code>dateCutoff</code> equivalent to Date instance that is 365 days ago) BUT the first scrape only went as far back as day 100, then any subsequent scrapes will only return the latest orders within that 100 days.</li> </ul> <p>Subsequent scrapes will continue to fetch historical orders until <code>dayCutoff</code> OR <code>dateCutoff</code> is reached, and after that, scrapes will only go back to the last scrape date.</p> <ul> <li>If the <code>dayCutoff</code> was set to 365 days (OR <code>dateCutoff</code> equivalent to Date instance that is 365 days ago) BUT the first scrape only went as far back as 100 days, then subsequent scrapes would still attempt to get all of the orders within that 365 day window before starting to grab latest orders.</li> </ul>"},{"location":"configuring_client_alp/#latest-orders-only","title":"Latest Orders Only","text":"<p>The <code>latestOrdersOnly</code> property specifies at what point the SDK stops searching for orders.</p> <p>Example: <code>dayCutoff</code> is set to 14 days, and you retrieve orders. After that, you set the <code>dayCutoff</code> to 28 days. If <code>latestOrdersOnly</code> is set to true, you will only get orders which are newer than the latest order you received the first time. If it is set to <code>false</code>, you will also get orders which are older than those you got when retrieving orders with a 14 days cutoff, and at the same time inside the 28-day window.</p> <p>You can specify this with the <code>latestOrdersOnly</code> property on the <code>AccountLinkingClient</code> instance, i.e.:</p> KotlinJava <pre><code>val client = AccountLinkingClient(context)\nclient.latestOrdersOnly = false\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\nclient.latestOrdersOnly(false);\n</code></pre> <p>The property <code>latestOrdersOnly</code> is set to <code>true</code> by default, which means you will only get orders newer than the most recent order you\u2019ve received. If it\u2019s the first time you\u2019re retrieving orders, you will get all orders inside the cutoff window.</p>"},{"location":"configuring_client_alp/#country-code","title":"Country Code","text":"<p>The <code>countryCode</code> property specifies the code of the country in which the Account Linking SDK is used. Setting it correctly improves lookup results for the returned products. You can specify this with the <code>countryCode</code> property on the <code>AccountLinkingClient</code> instance, i.e.:</p> KotlinJava <pre><code>val client = AccountLinkingClient(context)\nclient.countryCode = \"US\"\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\nclient.countryCode(\"US\");\n</code></pre> <p>By default, it is set to <code>\"US\"</code>.</p>"},{"location":"digital_gmail/","title":"Gmail","text":"<p>Blink Receipt Digital sdk allows for full Gmail Integration.</p>"},{"location":"digital_gmail/#gmail-client","title":"Gmail Client","text":"<p>The <code>GmailClient</code> is the corner stone of the gmail sdk integration. It is the access point for reading and parsing emails from clients. It leverages Google\u2019s task framework to allow for seamless and clear multi-threading functionality.</p> <p>To instantiate the <code>GmailClient</code> you must provide the constructor 3 non-null and non-zero arguments.</p> <ol> <li> <p>Context: <code>Context</code>. When using the client within an Android <code>Activity</code> you can pass in <code>this</code> for the argument value. If using the client within an Android <code>Fragment</code> you can pass in <code>requireActivity()</code>.</p> </li> <li> <p>Thread Count: <code>int</code> which determines the number of threads to use for processing <code>e-receipt</code> emails. The internal default value we use is <code>4</code>.</p> </li> <li> <p>Client Id: <code>String</code> which comes from  Google\u2019s api services. Please refer here for more information on how to create an Android client id.</p> </li> </ol> <p></p>"},{"location":"digital_gmail/#code-sample-for-gmail-client-instantiation","title":"Code sample for Gmail Client Instantiation:","text":"Kotlin <pre><code>    // Activity Example\n    class GmailActivity: Activity() {\n\n        override fun onCreate(savedInstanceState: Bundle?) {\n            val gmailClient = GmailClient(this, 4)\n        }\n\n    }\n\n    // Fragment Example\n    class GmailFragment: Fragment() {\n\n        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n            val gmailClient = GmailClient(requireActivity(), 4)\n        }\n\n    }\n</code></pre>"},{"location":"digital_gmail/#logging-in-to-gmail","title":"Logging In To Gmail","text":"<p>Users may log in to gmail via the client\u2019s <code>login()</code> function. There is an overloaded login function which takes in an Android <code>Activity</code>, <code>login(Activity activity)</code>. Passing the <code>Activity</code> allows for our components to be lifecycle aware and not leak memory. This parameter is optional though and not required for any explicit extra functionality.</p> <p>The login call returns a Google <code>Task</code> of type <code>GoogleSignInAccount</code>. The <code>GoogleSignInAccount</code> is an object which contains the basic account information of the signed in Google user. The reference for GoogleSignInAccount can be found here.</p> <p><code>login()</code> can be called from any thread, because the return type is a <code>Task&lt;GoogleSignInAccount&gt;</code>. If you read the previous section of this document on the Task framework you should have some familiarity with how this process works.</p> <p>Let\u2019s step through the different login scenario results that can occur and how to provide proper handling of each scenario.</p> <p></p>"},{"location":"digital_gmail/#successful-login-scenario","title":"Successful Login Scenario","text":"<p>A successful login attemt will return a valid <code>GoogleSignInAccount</code>. This sign in account can be captured via an <code>OnSuccessListener</code> call.</p> <p>Here is an example of some happy case scenarios when calling the login() function.</p> Kotlin <pre><code>    fun loginUser() {\n        val task: Task&lt;GoogleSignInAccount&gt; = gmailClient.login()\n\n        task.addOnSuccessListener {\n\n        }\n    }\n</code></pre> <p></p>"},{"location":"digital_gmail/#unsuccessful-login-scenario","title":"Unsuccessful Login Scenario","text":"<p>A login attempt can fail for a number of reasons. Google has integrated its sign in flow into the Android system. For safety reasons, calling login does not always automatically sign the default user in to your application. It is possible that Google may require extra authentication when you attempt to signIn. The Gmail Integration of the sdk provides an easy to use wrapper around Google\u2019s authentication handling. When calling login it is possible for exceptions to be thrown. We try to make exception handling as easy as possible for you. Therefore, we have created our own easy to use exceptions that will allow your app proper recourse in the event of a failure.</p> <p>GmailAuthException</p> <p>One of the most important exceptions to look out for is the <code>GmailAuthException</code>. This exception occurs in the event of any silent authentication exceptions. This exception is extremely important, because it could potentially contain a recourse for a user to take upon an unsuccessful sign in. The exception potentially contains an Android <code>Intent</code> this is an intent that has been provided by Google and meant to be launched by the app developer to obtain an explicit approval from the app user. The intent must be triggered with a <code>startActivityForResults()</code> call. This call is a method within Android components (Activity, Fragment). It takes in an <code>Intent</code> as well as an <code>int</code> which denotes the identifying <code>requestCode</code>. Starting this activity for result will display an overlaying window that will display the user\u2019s registered accounts on the device.</p> <p>Once a user has selected their desired account the overlaying screen will automatically dismiss and the <code>onActivityResult(int requestCode, int resultCode, Intent data)</code> callback overridden within your Android component (Activity or Fragment) will be invoked. There is no need to handle the result and data yourself, the gmail client provides an easy to use function to handle this. Simply call <code>gmailClient.onAccountAuthorizationActivityResult()</code>, passing in the <code>requestCode</code>, <code>resultCode</code>, and <code>data</code> respectively.</p> <p>The <code>onAccountAuthorizationActivityResult</code> function also returns a task of type <code>GoogleSignInAccount</code>. If the sign is successful then the Intent data passed in usually contains the desired <code>GoogleSignInAccount</code> which the client parses and returns to you in the form of a result. If the sign in is NOT successful the returned task will throw an exception notifying your app of the failed result.</p> <p>NOTE Most common cause for an exception in this scenario is the user, when presented with the Google Sign In Screen Overlay, opted not to choose any account and clicked the cancel option in the modal.</p> <p>NOTE THIS <code>GmailAuthException</code> SCENARIO WILL MOST LIKELY BE THE USER EXPERIENCE FLOW THE FIRST TIME A USER SIGNS IN TO YOUR APP</p> <p>EXAMPLE GMAIL LOGIN IMPLEMENTATION</p> Kotlin <pre><code>class GmailInboxFragment : Fragment() {\n\n    private lateinit var gmailClient: GmailClient\n\n    //...Instantiate GmailClient in one of the lifecycle methods\n\n    // Attempt to login\n    fun login() {\n        gmailClient.login()\n                .addOnSuccessListener {\n\n                }.addOnFailureListener { e -&gt;\n                    if (e is GmailAuthException) {\n                        startActivityForResult(e.signInIntent, e.requestCode)\n                    } else {\n                        //Set error display\n                    }\n                }\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n\n        gmailClient.onAccountAuthorizationActivityResult(requestCode, resultCode, data)\n           .addOnSuccessListener { signInAccount -&gt;\n\n        }.addOnFailureListener {\n            //Set error display\n        }\n    }\n}\n</code></pre> <p>Once a user has successfully signed in we are good to go! We can now move on to retrieving emails from a signed in user.</p> <p></p>"},{"location":"digital_gmail/#verifying-gmail-log-in-and-retrieving-already-signed-in-users","title":"Verifying Gmail Log In And Retrieving Already Signed In Users","text":"<p>So as not to constantly bombard users with a typical sign in flow, we provide the <code>verify()</code> function on the <code>GmailClient</code>. The <code>verify()</code> call returns a <code>Task&lt;Boolean&gt;</code>. This boolean result returnes either <code>true</code> or <code>false</code>. If the result is <code>false</code> then this indicates that the sdk has no record of a signed in user. As a result you must take the user through the original sign in flow mentioned in the previous section.</p> <p>In the event, the result returns a <code>true</code> value, this indicates that we have an account signed in with Google. In which case, you can call <code>credentials()</code> on the <code>GmailClient</code>. The <code>credentials()</code> call returns a <code>Task&lt;GoogleSignInAccount&gt;</code>. This will silently fetch the signed in user\u2019s account and return it to the caller via the <code>Task</code>.</p> <p>EXAMPLE GMAIL VERIFY AND CREDENTIALS IMPLEMENTATION</p> Kotlin <pre><code>     private fun verifyUser() {\n        gmailClient.verify()\n            .addOnSuccessListener {\n\n            }.addOnFailureListener {\n\n            }\n    }\n</code></pre> <p></p>"},{"location":"digital_gmail/#logging-out-of-gmail","title":"Logging Out of Gmail","text":"<p>Users may log out of gmail via the client\u2019s <code>logout()</code> function. The logout function will return a <code>Task&lt;Boolen&gt;</code>. This function completes 2 objectives. First, it signs the currently signed in user out from Gmail/Google SDK. This means that the user can no longer be \u201csilently\u201d signed in to Google. The next time the <code>verify()</code> is called a <code>false</code> result should be returned via the <code>Task</code> return object. This also means that the <code>credentials()</code> call will not return a <code>GoogleSignInAccount</code> result, but instead throw an exception (not unlike the initial user flow for sign in we covered before). Secondly, the <code>logout()</code> call will clear any cached \u201cdate\u201d threshold we use for email searching. You should never receive a <code>Boolean</code> result of <code>false</code> for the signout task. It will always either be true or throw an exception in the unlikely event of an error.</p> <p>EXAMPLE GMAIL LOGOUT IMPLEMENTATION</p> Kotlin <pre><code>    private fun logoutUser() {\n        gmailClient.logout().addOnSuccessListener {\n\n        }\n    }\n</code></pre> <p></p>"},{"location":"digital_gmail/#reading-messages-and-getting-results","title":"Reading Messages And Getting Results","text":"<p>After a user has been signed in to their Gmail Account, we can now fetch their emails and find any receipts they may have stored in their email. Before we initiate a search, we want to make sure we have properly configured the <code>GmailClient</code>. All sdk email clients have properties that can be configured to optimize searching. Here is a list of the following properties</p> Property Name Type Default Value Client Function Description dayCutoff Int 14 dayCutoff(int days) Maximum number of days look back in a users inbox for receipts filterSensitive Boolean false filterSensitive(boolean filterSensitive) When set to true the sdk will not return product results for products deemed to be sensitive i.e. adult products subProducts Boolean false subProducts(boolean subProducts) Enable sdk to return subproducts found on receipts under parent products i.e. \u201cBurrito + Guacamole &lt;- Guac is subproduct\u201d countryCode String \u201cUS\u201d countryCode(String countryCode) Helps classify products and apply internal product intelligence <p>Once the client is configured then we are ready to start parsing emails. On the <code>GmailClient</code> call <code>messages(@NonNull Activity activity)</code> to begin the message reading. This call returns a <code>Task&lt;List&lt;ScanResults&gt;&gt;</code>. The calling of this function completes a series of tasks internally, before potentially returning a <code>List&lt;ScanResults&gt;</code>. Upon a successful execution, the task will emit a result of <code>List&lt;ScanResults&gt;</code>. If no results were able to be found, then the list will be empty. If results were found then each item in the list will represent a successfully scanned receipt. Please use the ScanResults data to display information to users or use for internal use.</p> <p></p> <p>EXAMPLE GMAIL READ MESSAGES</p> Kotlin <pre><code>    fun messages() {\n      client.messages(requireActivity())\n       .addOnSuccessListener { results -&gt;\n\n       }.addOnFailureListener {\n\n       }\n    }\n</code></pre>"},{"location":"digital_gmail/#gmailclient-destroy-client","title":"GmailClient Destroy Client","text":"<p>We always want to make sure we are adhereing to any component\u2019s lifecycle. Therefore, it is very important to call destroy within the component. This will clean up any pending calls, and allocated resources.</p> Kotlin <pre><code>override fun onDestroy() {\n    super.onDestroy()\n\n    client.close()\n}\n</code></pre>"},{"location":"digital_imap/","title":"IMAP","text":""},{"location":"digital_imap/#android-manifest","title":"Android Manifest","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n\n    &lt;application\n        android:name=\".BlinkApplication\"\n        android:allowBackup=\"false\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"&gt;\n\n        &lt;meta-data\n            android:name=\"com.microblink.ProductIntelligence\"\n            android:value=\"KEY\" /&gt;\n\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre>"},{"location":"digital_imap/#themes-styles","title":"Themes &amp; Styles","text":"<p>IMAP authorization UI uses the material bottom sheet. This requires your theme parent to extend <code>Theme.MaterialComponents.*</code></p> <pre><code>&lt;resources&gt;\n\n    &lt;!-- Base application theme. --&gt;\n    &lt;style name=\"AppTheme\" parent=\"Theme.MaterialComponents.Light.NoActionBar\"&gt;\n        &lt;!-- Customize your theme here. --&gt;\n        &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt;\n        &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt;\n        &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;\n    &lt;/style&gt;\n\n&lt;/resources&gt;\n</code></pre>"},{"location":"digital_imap/#imap-client","title":"IMAP Client","text":"<p>IMAP client is the main entry point which allows the SDK to connect to imap accounts. Initializing the client is asynchronous and requires the caller to wait until its complete before accessing the imap messages or account information. Note: if you use lazy this will cause exceptions until the client has been initialized. This is on a per instance basis.</p> Kotlin <pre><code>ImapClient( applicationContext, object : InitializeCallback {\n\n    override fun onComplete() {\n\n    }\n\n    override fun onException(throwable: Throwable) {\n\n    }\n  }\n)\n</code></pre>"},{"location":"digital_imap/#credentials","title":"Credentials","text":"<p>A <code>Credentials</code> object defines the credentials being used to login to a specific IMAP provider. <code>Credentials</code> is a sealed class that contains 2 subtypes: <code>None</code> and <code>Password</code>, each of which contains a collection of subtypes corresponding to the IMAP provider.</p> Kotlin <pre><code>    sealed class Credentials {\n        sealed class None {\n            data class Gmail(val appPassword: AppPassword)  \n        }\n        sealed class Password {\n            data class Gmail(val username: String, val password: String)\n            data class Yahoo(val username: String, val password: String)\n            data class Aol(val username: String, val password: String)\n        }\n    }\n</code></pre> <p><code>Credentials.Password</code> accepts username and password inputs from the application UI. <code>Credentials.None</code> allows for IMAP web authentication (where the user inputs credentials via the provider\u2019s WebView login page), which is functionally analogous to the BlinkReceipt Account Linking SDK where Retailer Web Auth is enabled using <code>Credentials.NONE</code>. The <code>AppPassword</code> enum parameter in <code>None</code> is used to specify whether the user has to manually input a Gmail app password name during the authentication process (<code>AppPassword.MANUAL</code>) or the Gmail app password name should be automatically injected using your application\u2019s name (<code>AppPassword.AUTOMATIC</code>). If this enum flag is not specified, <code>AppPassword.AUTOMATIC</code> will be used by default.</p> <p>Note: <code>Credentials</code> replaces <code>PasswordCredentials</code> in the IMAP public API surface starting from version 1.8.6.</p> <p>Note: Linking with <code>Credentials.None.Gmail</code> will cause a <code>Credentials.Password.Gmail</code> to be saved to disk if login is successful. The saved <code>Credentials.Password.Gmail</code> object can be retrieved for other operations.</p>"},{"location":"digital_imap/#provider-setup","title":"Provider Setup","text":"<p>To start the IMAP account linking process, we first create a <code>Credentials</code> object, then call <code>ProviderSetupFragmentFactory.create(credentials)</code> that returns a <code>ProviderFragment</code>. The fragment accepts a callback that receives a <code>ProviderResults</code> object containing a <code>Credentials</code> and a <code>ProviderSetupResults</code> enum. The callback will be invoked after the authentication process is finished.</p> <p>Example: Gmail (web authentication) workflow</p> Kotlin <pre><code>val credentials: Credentials = Credentials.None.Gmail()\n\nProviderSetupFragmentFactory.create(credentials).callback { result: ProviderResult -&gt;\n    // do something upon receiving provider result\n}.show(supportFragmentManager, TAG)\n</code></pre> <p>Example: Gmail (traditional) authentication workflow</p> Kotlin <pre><code>val credentials: Credentials = Credentials.Password.Gmail(\n    \"email@microblink.com\", \n    \"account password\"\n)\n\nProviderSetupFragmentFactory.create(credentials).callback { result: ProviderResult -&gt;\n    // do something upon receiving provider result\n}.show(supportFragmentManager, TAG)\n</code></pre> <p>Note: <code>ProviderSetupDialogFragment.newInstance(provider)</code> is no longer supported since version 1.8.6.</p> <p>Note: The <code>ProviderResults</code> callback result will only contain valid and authenticated credentials if <code>ProviderSetupResults</code> is <code>CREATED_APP_PASSWORD</code>. Otherwise, <code>ProviderResults</code> contains the original credentials you created.</p> <p>Note: <code>Credentials.None</code> should only be used here at account login, and not at any other public API.</p>"},{"location":"digital_imap/#imap-login-toverify-account","title":"IMAP Login To/Verify Account","text":"<p>The <code>verify()</code> function is used to determine if the sdk has any cached <code>Credentials.Password</code> that can be used without explicit sign in. This can be called without any parameters or with an <code>Executor</code> and <code>Credentials.Password</code>. The empty parameter function call will automatically attempt to fetch the cached <code>Credentials.Password</code> within the sdk and verify it against the ImapService. This function call returns a <code>Task&lt;Boolean&gt;</code>. When the result emitted is a <code>true</code> value, then the <code>Credentials.Password</code> that were either passed in or cached in the sdk grant access to a valid account. In the event an exception is thrown, that means that the <code>Credentials.Password</code>, either passed in or cached, are not valid to access a specific account.</p> Kotlin <pre><code>val credentials: Credentials.Password = Credentials.Password.Gmail(\"email@microblink.com\", \"account password\")\n\nclient.verify(credentials).addOnSuccessListener { isVerified: Boolean -&gt;\n\n}.addOnFailureListener {\n\n}\n</code></pre>"},{"location":"digital_imap/#imap-credentials","title":"IMAP Credentials","text":"<p>The <code>accounts()</code> function is used to fetch the cached account\u2019s <code>Credentials.Password</code> on the sdk. This is usually called AFTER <code>verify()</code>, once a client can verify that there is a valid account on the sdk. This does not verify the account credentials. It only fetches them from our encrypted cache and returns them to the caller.</p> Kotlin <pre><code>client.accounts().addOnSuccessListener { accounts: List&lt;Credentials.Password&gt; -&gt;\n\n}.addOnFailureListener {\n\n}\n</code></pre>"},{"location":"digital_imap/#imap-messages","title":"IMAP Messages","text":"<p>After a user has been signed in to their IMAP Account, we can now fetch their emails and find any receipts they may have stored in their email. Before we initiate a search, we want to make sure we have properly configured the <code>ImapClient</code>. All sdk email clients have properties that can be configured to optimize searching. Here is a list of the following properties</p> Property Name Type Default Value Client Function Description dayCutoff Int 14 dayCutoff(int days) Maximum number of days look back in a users inbox for receipts filterSensitive Boolean false filterSensitive(boolean filterSensitive) When set to true the sdk will not return product results for products deemed to be sensitive i.e. adult products subProducts Boolean false subProducts(boolean subProducts) Enable sdk to return subproducts found on receipts under parent products i.e. \u201cBurrito + Guacamole &lt;- Guac is subproduct\u201d countryCode String \u201cUS\u201d countryCode(String countryCode) Helps classify products and apply internal product intelligence sendersToSearch Map\\&lt;String, Merchant&gt; null sendersToSearch(Map\\&lt;String, Merchant&gt; sendersToSearch) This allows clients to search for merchants that may have sent receipts under a different email. For example, Target may have sent an email from \u201creceipts@uniquetarget.com\u201d. It is still a Target receipt, but under a different email. Therefore, the client can provide a Merchant like <code>mapOf( \"receipts@uniquetarget.com\" to  Merchant( \"Target.com\", \"receipts@uniquetarget.com\"))</code>. <p>Once the client is configured then we are ready to start parsing emails. On the <code>ImapClient</code> call <code>messages(@NonNull MessagesCallback callback)</code> to begin the message reading. The calling of this function completes a series of tasks internally, before potentially returning a list of <code>List&lt;ScanResults&gt;</code> via the <code>MessagesCallback</code> parameter. Upon a successful execution, the callback will emit a result of <code>List&lt;ScanResults&gt;</code> from the overriden onComplete() function. The number of <code>onComplete()</code> emissions depends on the number IMAP accounts you have credentials for. The <code>messages(...)</code> function will attempt to read messages based on the specified configuration set on the client for each account logged in. In addition to a List, each emission of onComplete will give you the <code>Credentials.Password</code> of the corresponding account from which the scan results were derived from. Within the callback, there is an onException interface method. This will be triggered in the event of an error fetching messages from an account. The account e-mail retrieval process is segregated from each other. Therefore, failure to retrive messages from one account doesn\u2019t mean a failure to retrieve messages from all accounts. It is entirely possible, to receive an onException callback AND an onComplete callback within a single <code>messages(...)</code> call. If results were found then each item in the list will represent a successfully scanned receipt. Please use the ScanResults data to display information to users or use for internal use. <p>EXAMPLE IMAP READ MESSAGES</p> Kotlin <pre><code>    fun messages() {\n      client.messages(\n          object: MessagesCallback {\n              override fun onComplete(credentials: Credentials.Password, result: List&lt;ScanResults&gt;) {\n                  // do stuff with scan results\n                  // see credentials of account\n              }\n\n              override fun onException(throwable: Throwable) {\n                  Toast.makeText(getContext(), throwable.toString(), Toast.LENGTH_SHORT).show\n              }\n          }\n      )\n    }\n</code></pre>"},{"location":"digital_imap/#imap-remote-messages","title":"IMAP Remote Messages","text":"<p>The <code>messages()</code> function is responsible for fetching emails and parsing those emails on the device. This is the normal behavior of the sdk. However, we now have <code>remoteMessages(@NonNull JobResultsCallback callback)</code>. This function is similar to messages, but instead of parsing the emails on the device, it will parse the emails on the server. The JobResultsCallback.onComplete(\u2026) function will trigger upon a completed operation. Within the callback users will receive <code>credentials: Credentials.Password</code> and <code>result: JobResults</code>. The <code>Credentials.Password</code> is covered in other parts of the documentation. The <code>JobResults</code> parameter will give you a reference to the server job. In addition to the server job id, it will also let you know if the job was successful, or if there were any errors with your request.</p>"},{"location":"digital_imap/#imap-logout","title":"IMAP Logout","text":"<p>When you wish to sign out from a user\u2019s current account use the <code>logout()</code> function on the <code>ImapClient</code>. The logout function will sign a user out of their account and clear the credentials cached in the sdk. The return type is a <code>Task&lt;Boolean&gt;</code>. When a successful <code>true</code> result is given then it can be assumed that the client has successfully cleared all stored credentials and data for a user. If an exception is thrown then, there could have been an issue with one or more of the tasks executed to complete the logout functionality.</p> Kotlin <pre><code>val credentials: Credentials.Password = Credentials.Password.Gmail(\n    \"email@microblink.com\",\n    \"account password\"\n)\n\nclient.logout(Credentials).addOnSuccessListener {\n\n}.addOnFailureListener {\n\n}\n</code></pre>"},{"location":"digital_imap/#imap-clear","title":"IMAP Clear","text":"<p>In order to optimize, fetching and parsing emails, we try to not to duplicate work. One of these optimizations comes in the form of a cached last date search. This cached value allows us to keep track of the last time a search was done, so that we can optimize our search paramters and not fetch duplicate emails that we have already seen. However, there may be a scenario where the client will want to clear this cache and fetch all emails within the <code>dayCutoff</code> value. If you fall into this scenario, and wish to clear our cached date flag, then call <code>clearLastCheckedTime()</code>. Thi returns a <code>Task&lt;Boolean&gt;</code> and will let you know based on the boolean result whether or not we were able to successfully clear our cached date.</p> Kotlin <pre><code>client.clearLastCheckedTime().addOnSuccessListener {\n\n}\n</code></pre>"},{"location":"digital_imap/#imap-destroy-client","title":"IMAP Destroy Client","text":"<p>We always want to make sure we are adhering to any component\u2019s lifecycle. Therefore, it is very important to call destroy within the component. This will clean up any pending calls, and allocated resources.</p> Kotlin <pre><code>   override fun onDestroy() {\n       super.onDestroy()\n\n       client.close()\n   }\n</code></pre>"},{"location":"digital_imap/#exception-handling","title":"Exception Handling","text":"<p>The sdk will throw exceptions in the event it runs into an error while fetching emails. Here are some helpful explanations of common exception messages you may run into while using the sdk.</p> Function Exception Message Explanation messages() \u201cunable to find provider accounts\u201d While fetching the cached email accounts on the device, there were no accounts found in the cache. These could have been removed by the <code>logout()</code> function, or some other data clearing action. The only recourse is to readd the accounts. logout() \u201cunable to store this provider \u201d + provider While attempting to logout of a provided account, the specified account was not found in the cache verify() \u201cunable to connect to imap service!\u201d There was an error in connecting to the IMAP client. It could be an issue with the server, or the credentials. You can try again later or have a user reinput their credentials. remoteMessages() \u201cUnable to encrypt credentials \u201c+ credentials.username() Credentials are encrypted and stored for easy access. When provided we attempt to encrypt the provided credentials. In the event of a failure this exception will be thrown informing you of the error."},{"location":"digital_integration/","title":"Project Integration and Instantiation","text":"<p>Please follow the Project Integration and Initialization, R8/Proguard, and the application class/manifest step in the Scanning Your First Receipt sections to properly add and initialize recognizer sdk.</p> <p>To add the sdk to your android project please follow these steps:</p> <ol> <li>Add the following maven repository to your build.gradle or settings.gradle, depending on your implementation:</li> </ol> Groovy <pre><code>repositories {\n  maven { url  \"https://maven.microblink.com\" }\n}\n</code></pre> <ol> <li>Add the following to your dependency section in your app <code>build.gradle</code>.</li> </ol> Groovy <pre><code>dependencies {\n    implementation(platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\"))\n\n    implementation(\"com.microblink.blinkreceipt:blinkreceipt-digital\")\n    implementation(\"com.microblink.blinkreceipt:blinkreceipt-recognizer\")\n}\n</code></pre> <p>Initialize the <code>BlinkReceiptDigitalSdk</code> in your application class.</p> Kotlin <pre><code>class BlinkApplication : Application() {\n\n    override fun onCreate() {\n        super.onCreate()\n\n        BlinkReceiptDigitalSdk.initialize(this, object : InitializeCallback {\n\n            override fun onComplete() {\n\n            }\n\n            override fun onException(e: Throwable) {\n\n            }\n\n        })\n    }\n}\n</code></pre>"},{"location":"digital_outlook/","title":"Outlook","text":"<p>You must register an application in the MS Application Registration Portal, add a Native Application platform, and obtain an Application ID.</p>"},{"location":"digital_outlook/#android-manifest","title":"Android Manifest","text":"<pre><code>&lt;activity android:name=\"com.microsoft.identity.client.BrowserTabActivity\"&gt;\n     &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n\n        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n        &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n\n         &lt;data android:host=\"com.blinkreceipt.development\"\n          android:path=\"/[Signature Hash]\"\n          android:scheme=\"msauth\" /&gt;\n     &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre>"},{"location":"digital_outlook/#authentication-configuration","title":"Authentication Configuration","text":"<p>Outlook client will reference the authentication configuration file location in resources raw folder. Create auth_config_single_account.json under res/raw</p> <p>Single Account <pre><code>{\n  \"client_id\" : \"[CLIENT ID]\",\n  \"authorization_user_agent\" : \"DEFAULT\",\n  \"redirect_uri\" : \"[REDIRECT URI]\",\n  \"account_mode\" : \"SINGLE\",\n  \"broker_redirect_uri_registered\": true,\n  \"authorities\" : [\n    {\n      \"type\": \"AAD\",\n  \"authority_url\": \"https://login.microsoftonline.com/common\"\n  }\n  ]\n}\n</code></pre></p>"},{"location":"digital_outlook/#outlook-client","title":"Outlook Client","text":"<p>Outlook client is the main entry point which allows the SDK to connect to outlook accounts. Initializing the client is asynchronous and requires the caller to wait until its complete before accessing the outlook messages or account information. Note: if you use lazy this will cause exceptions until the client has been initialized. This is on a per instance basis.</p> Kotlin <pre><code>OutlookClient(applicationContext, R.raw.auth_config_single_account, object : InitializeCallback {\n\n    override fun onComplete() {\n\n    }\n\n    override fun onException(throwable: Throwable) {\n\n    }\n\n})\n</code></pre>"},{"location":"digital_outlook/#outlook-login","title":"Outlook Login","text":"Kotlin <pre><code>    client.login(this).addOnSuccessListener {\n\n   }.addOnFailureListener {\n\n   }\n</code></pre>"},{"location":"digital_outlook/#outlook-logout","title":"Outlook Logout","text":"Kotlin <pre><code>client.logout().addOnSuccessListener {\n\n}.addOnFailureListener {\n\n}\n</code></pre>"},{"location":"digital_outlook/#outlook-messages","title":"Outlook Messages","text":"<p>Messages returns a Task, which allows you to get a list of scan results for messages found in the Outlook mailbox.</p> Kotlin <pre><code> client.messages().addOnSuccessListener {\n\n}.addOnFailureListener {\n\n}\n</code></pre>"},{"location":"digital_outlook/#outlook-destroy-client","title":"Outlook Destroy Client","text":"Kotlin <pre><code>override fun onDestroy() {\n    super.onDestroy()\n\n    client.close()\n}\n</code></pre>"},{"location":"digital_requirements/","title":"Requirements","text":"<ul> <li>AndroidX</li> <li>Min SDK 23+</li> <li>Compile SDK: 36+</li> <li>Java 17+</li> </ul>"},{"location":"digital_requirements/#product-intelligence","title":"Product Intelligence","text":"<p>If you wish to include product intelligence functionality within your project add your license key to the <code>AndroidManifest.xml</code> file, similar to the setup for this sdk.</p> <p><code>AndroidManifest.xml</code> <pre><code> &lt;meta-data android:name=\"com.microblink.ProductIntelligence\" android:value=\"PRODUCT INTELLIGENCE KEY\" /&gt;\n</code></pre></p>"},{"location":"digital_tasks/","title":"Tasks","text":"<p>The Blink Receipt Digital Sdk heavily leverages Google\u2019s Task for result and exception handling when interfacing with the sdk. Here is a high level comprehensive guide on how to use the Task framework.</p> <p>The <code>Task&lt;T&gt;</code> object, returned by most functions in the sdk, can be thought of as a reference to a job being done either on the main thread or a background thread. The <code>T</code> represents the type of result that task is expected to return when done executing it\u2019s logic.</p>"},{"location":"digital_tasks/#handling-results-from-a-task","title":"Handling Results From A Task","text":"<p>When you have a Task, you are able to apply different sets of listeners that will receive your result or catch your exceptions. There are 2 ways to approach this result handling</p>"},{"location":"digital_tasks/#first-way-recommended","title":"First Way (Recommended)","text":"<p>A successful callback listener, <code>OnSuccessListener&lt;? super TResult&gt;</code>, can be added to the task by calling <code>task.addOnSuccessListener(OnSuccessListener&lt;? super TResult&gt;)</code>. This listener has a single method <code>onSuccess(T result)</code> that needs to be implemented. This listener callback will be invoked upon a successful completion of a given Task.</p> JavaKotlin <pre><code>    Task&lt;Foo&gt; exampleTask = repository.fetchFoo();\n\n    exampleTask.addOnSuccessListener( new OnSuccessListener&lt;Foo&gt;() {\n        @Override\n        public void onSuccess(Foo foo) {\n            // Do something\n        }\n    } );\n</code></pre> <pre><code>    val exampleTask: Task&lt;Foo&gt; = repository.fetchFoo();\n\n    exampleTask.addOnSuccessListener { foo -&gt; // Do something }\n</code></pre> <p>Unfortunately, as we know all too well, things do not always go as planned. Exceptions can occur and it is important that we handle those scenarios in the event we wish to provide some sort of recourse for the user. There is a compliment listener that can be added to a <code>Task</code> for exception handling. This listener is called a <code>OnFailureListener</code>, and it can be added by calling <code>task.addOnFailureListener(OnFailureListener listener)</code>. This also has one method, <code>onFailure(@NonNull Exception e)</code>, that needs to be implemented. This callback will be invoked in the event any exception is thrown by the task itself.</p> JavaKotlin <pre><code>    Task&lt;Foo&gt; exampleTask = repository.fetchFoo();\n\n    exampleTask.addOnFailureListener( new OnFailureListener() {\n        @Override\n        public void onFailure(Exception exception) {\n            // Do something\n        }\n    } );\n</code></pre> <pre><code>    val exampleTask: Task&lt;Foo&gt; = repository.fetchFoo();\n\n    exampleTask.addOnFailureListener { exception -&gt; // Do something }\n</code></pre> <p>Result listeners can be chained for a cleaner look.</p> Java <pre><code>    Task&lt;Foo&gt; exampleTask = repository.fetchFoo();\n\n    exampleTask.addOnSuccessListener( new OnSuccessListener&lt;Foo&gt;() {\n        @Override\n        public void onSuccess(Foo foo) {\n            // Do something\n        }\n    } ).addOnFailureListener( new OnFailureListener() {\n        @Override\n        public void onFailure(Exception exception) {\n            // Do something\n        }\n    } );\n</code></pre>"},{"location":"digital_tasks/#second-way-not-recommended","title":"Second Way (Not Recommended)","text":"<p>We believe it is better to separate out the two outcomes of a task, but not all share the same philosophy. This method of result and exception handling combines both eventualities into a single callback, <code>OnCompleteListener&lt;TResult&gt; listener</code>. This has a single abstract method which will be implemented <code>onComplete (Task&lt;TResult&gt; task)</code>. The invoking of this callback does not signify a successful or a failed task result. Extra logic must be added to make that determination. The <code>OnCompleteListener</code> gives you a reference to the task. It is from here that you can do status checks <code>task.isSuccessful()</code>, <code>task.isCompleted()</code>, or <code>task.isCanceled()</code>. The result of the task can be retrieved by calling <code>task.getResult()</code>. Alternatively, the thrown exception can be retrieved with a simple <code>task.getException()</code> call.</p> <p>WARNING Calling <code>task.getResult()</code> while the task is still executing or has already failed will result in a <code>IllegalStateException</code> and a <code>RuntimeException</code> respectively.</p>"},{"location":"fetch_orders_from_all_retailers/","title":"Fetch Orders from All Retailers","text":"<p>Starting from version 1.7.6, <code>AccountLinkingClient.orders(success:failure:)</code> function, where the SDK allows you to perform fetching ALL orders from ALL of your linked retailer(s), was already removed. Hence, a breaking API change. The main reason is that this method caused synchronization and race condition issues which led to unexpected results.</p> <p>In order to still achieve the same functionality to perform Fetch ALL order from ALL of your linked retailer(s), we highly recommend to follow a similar approach below:</p> Kotlin <pre><code>val client = AccountLinkingClient(context)\n// ...\n// Link retailers\n// ...\n\n// Execute the following code block under a suspend function\n// OR execute under a coroutine scope\ncoroutineScope.launch {\n    val retailerAccounts = withContext(Dispatchers.IO) {\n        client.accounts().await() ?: listOf()\n    }\n\n    // Collect Scan Results from each retailer. Each retailer can have multiple Scan Results.\n    val allOrdersScanResults = MutableStateFlow(listOf&lt;ScanResults&gt;())\n\n    // Create a sequence of callback flows that represents fetch orders from each retailer\n    val fetchOrderOperationFlowSequence = retailerAccounts.map { retailer -&gt;\n        callbackFlow&lt;Result&lt;Unit&gt;&gt; {\n            client.orders(\n                retailerId = retailer.retailerId,\n                success = { /*retailerId*/_: Int, results: ScanResults?, remaining: Int, /*uuid*/_: String -&gt;\n                    if(results != null) {\n                        // Append results\n                        allOrdersScanResults.update { current -&gt;\n                            ArrayList(current).apply { add(results) }\n                        }\n\n                        // Emit event\n                        trySend(\n                            Result.success(Unit)\n                        )\n                    }\n\n                    if(remaining &lt;= 0) {\n                        close()    // Close this callbackFlow since there are NO more remaining products to scan from this retailer\n                    }\n                },\n                failure = { _: Int, throwable: AccountLinkingException -&gt;\n                    trySend(Result.failure(throwable))\n                    close()\n                    // TODO:: Handle Error\n                },\n            )\n\n            awaitClose()\n        }\n    }\n        .asSequence()\n\n    // Iterate collect results in a SYNCHRONOUS and SEQUENTIAL manner.\n    flow {\n        for(orderOperation in fetchOrderOperationFlowSequence) {\n            emitAll(orderOperation)\n        }\n    }\n        .catch {\n            // TODO:: Handle Error\n        }\n        .collect()\n\n    if(allOrdersScanResults.value.isNotEmpty()) {\n        // You may SORT Scanned Results by Retailer\n        val sortedScannedResults = allOrdersScanResults.value\n            .sortedBy { it.retailerId().id() }\n        // TODO:: Show SCANNED RESULTS\n    } else {\n        // TODO:: Show EMPTY results prompt\n    }\n\n}\n</code></pre> <p>You may implement your own implementation of Fetch ALL Orders operation for as long as the execution is done in SYNCHRONOUS manner, execute Fetch Order operation from 1 retailer at a time.</p>"},{"location":"getting_started_alp/","title":"Getting Started","text":"<p>The Account Linking SDK enables you to easily add user-permissioned retailer connection functionality to your app with the purpose of extracting order history from online retailer accounts.</p> <p>It supports parsing digital and in-store orders from a growing list of online retailers.</p>"},{"location":"getting_started_alp/#integration","title":"Integration","text":"<ol> <li>Add the following maven repository to your build.gradle or settings.gradle, depending on your implementation:</li> </ol> KotlinGroovy <pre><code> repositories {\n   maven { url = uri(\"https://maven.microblink.com\") }\n }\n</code></pre> <pre><code> repositories {\n   maven { url \"https://maven.microblink.com\" }\n }\n</code></pre> <ol> <li>Add the following to your dependency section in your app <code>build.gradle</code>.</li> </ol> KotlinGroovy <pre><code>dependencies {\nimplementation(platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\"))\n\nimplementation(\"com.microblink.blinkreceipt:blinkreceipt-account-linking\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\")\n\nimplementation \"com.microblink.blinkreceipt:blinkreceipt-account-linking\"\n}\n</code></pre>"},{"location":"getting_started_alp/#setting-your-license-keys","title":"Setting your license keys","text":"<p>There are two ways you can set the license keys for the Account Linking SDK.</p>"},{"location":"getting_started_alp/#android-manifest","title":"Android Manifest","text":"<p>In your <code>AndroidManifest.xml</code> file, create the following <code>meta-data</code> tags, and insert your keys under the <code>android:value</code> attribute:</p> <pre><code>&lt;meta-data\n    android:name=\"com.microblink.LicenseKey\"\n    android:value=\"\"\n/&gt;\n\n&lt;meta-data\n    android:name=\"com.microblink.ProductIntelligence\"\n    android:value=\"\"\n/&gt;\n</code></pre> <p>License and Product Intelligence Keys can be obtained by emailing blinkreceipt@microblink.com.</p>"},{"location":"getting_started_alp/#programmatically","title":"Programmatically","text":"<p>If you want to set your keys programmatically, you can do so by setting them on the appropriate <code>BlinkReceiptLinkingSdk</code> fields in your application class in the <code>onCreate</code> method:</p> KotlinJava <pre><code>BlinkReceiptLinkingSdk.licenseKey = \"account_linking_license_key\"\nBlinkReceiptLinkingSdk.productIntelligenceKey = \"product_intelligence_license_key\"\n</code></pre> <pre><code>BlinkReceiptLinkingSdk.licenseKey(\"account_linking_license_key\");\nBlinkReceiptLinkingSdk.productIntelligenceKey(\"product_intelligence_license_key\");\n</code></pre>"},{"location":"getting_started_alp/#initializing-the-sdk","title":"Initializing the SDK","text":"<p>Before you can use the SDK it needs to be initialized. The best way to do this is to call the following function in your application class in the <code>onCreate</code> method:</p> KotlinJava <pre><code>BlinkReceiptLinkingSdk.initialize(this, object: InitializeCallback {\n    override fun onComplete() {\n    }\n\n    override fun onException(throwable: Throwable) {\n    // log exception...\n    }\n})\n</code></pre> <pre><code>BlinkReceiptLinkingSdk.initialize(this, new InitializeCallback() {\n    @Override\n    public void onComplete() {\n\n    }\n\n    @Override\n    public void onException(@NonNull Throwable throwable) {\n        // log exception\n    }\n});\n</code></pre> <p>That\u2019s it! You\u2019re all set up to use the Account Linking SDK. Check out the next chapter for more information on how to use the SDK.</p>"},{"location":"how_to_use_alp/","title":"How to use","text":""},{"location":"how_to_use_alp/#linking-accounts","title":"Linking Accounts","text":"<p>Before you can start retrieving orders, you have to link and verify an account. To link an account to the SDK, you have to instantiate an <code>Account</code> object and call the <code>link</code> method on an instance of the <code>AccountLinkingClient</code> class.</p> <p>Account Linking offers two UI/UX experiences when linking and verifying a retailer\u2019s connection. Depending on your app needs you can choose:</p>"},{"location":"how_to_use_alp/#1-host-app-authentication","title":"1. Host App Authentication","text":"<p>Using this flow, the client\u2019s host app provides a native prompt for users to populate credentials. All other interactions with the merchant are done with the webview hidden in the background with exception when 2FA, Captcha or other required user input.</p> KotlinJava <pre><code>// AMAZON is used just as an example\nval account = Account(\n    retailerId = AMAZON,\n    credentials = Credentials.Password(\n        \"amazon_username\",\n        \"amazon_password\"\n    )\n)\n\nclient.link(account).addOnSuccessListener {\n    //move on to the next step, verifying the account or retrieving orders\n}.addOnFailureListener {\n    //linking shouldn't fail, as the API forbids you from using an invalid retailer ID.\n}\n</code></pre> <pre><code>Account account = new Account(\n    AMAZON,\n    new Credentials.Password(\n        \"amazon_username\",\n        \"amazon_password\"\n    )\n);\n\nclient.link(account).addOnSuccessListener(success -&gt; {\n    //move on to the next step, verifying the account or retrieving orders\n})\n.addOnFailureListener (exception -&gt;{\n    //linking shouldn't fail, as the API forbids you from using an invalid retailer ID.\n});\n</code></pre> <ul> <li>Collect the user\u2019s credentials for a given retailer using your own UI</li> </ul>"},{"location":"how_to_use_alp/#2-retailer-web-view-authentication","title":"2. Retailer Web View Authentication","text":"<p>Using this flow the host app doesn\u2019t need to provide any native functionality to collect credentials but instead present a WebView with retailer\u2019s webpage pre-populated. All steps needed for authentication, a user may handle in the same WebView.</p> KotlinJava <pre><code>// AMAZON is used just as an example.\nval account = Account(\n    retailerId = AMAZON,\n    credentials = Credentials.None // No need to explicitly provide credentials\n)\n\nclient.link(account).addOnSuccessListener {\n    //move on to the next step, verifying the account or retrieving orders\n}.addOnFailureListener {\n    //linking shouldn't fail, as the API forbids you from using an invalid retailer ID.\n}\n</code></pre> <pre><code>Account account = new Account(\n    AMAZON,\n    Credentials.None.INSTANCE\n    true\n);\n\nclient.link(account).addOnSuccessListener(success -&gt; {\n    //move on to the next step, verifying the account or retrieving orders\n})\n.addOnFailureListener (exception -&gt;{\n    //linking shouldn't fail, as the API forbids you from using an invalid retailer ID.\n});\n</code></pre> <ul> <li>Already linked connections can be switched back and forward by invoking again <code>AccountLinkingClient.link()</code>, passing an updated <code>Account</code> instance.</li> </ul> <p>The <code>link</code> method takes in a <code>vararg</code> of <code>Account</code>, so you can link multiple accounts (for different retailers) at once if needed</p> <p>By linking the account, the details of that account (e.g. <code>retailerId</code>, <code>credentials</code> field values) is cached locally and encrypted for future use and can be retrieved using the <code>accounts</code> method.</p> <p>Warning</p> <p>Only one account can be linked per retailer at once. E.g. you can only link one Walmart account. If you try to link another Walmart account, the old account will be removed and the new account will be linked.</p> <p>Similarly, accounts can be unlinked, by which they are removed from the device cache. Here\u2019s an example of a flow you might have in your implementation:</p> KotlinJava <pre><code>val client = AcountLinkingClient(context)\nclient.link(\n    Account(\n        AMAZON,\n        Credentials.Password(\n            \"amazon_username\",\n            \"amazon_password\"\n        )\n    )\n)\n//do some work, verify, grab orders, etc...\n\n//retrieve and unlink account\nclient.accounts().addOnSuccessListener {\n    val amazonAccount = it?.firstOrNull { it.retailerId == AMAZON }\n    if (amazonAccount != null) {\n        client.unlink(amazonAccount).addOnSuccessListener {\n            //i.e. link another Amazon account\n        }\n    }\n}\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\nclient.link(\n    new Account(\n        AMAZON,\n        new Credentials.Password(\n            \"amazon_username\",\n            \"amazon_password\"\n        )\n    )\n);\n//do some work, verify, grab orders, etc...\n\n//retrieve and unlink account\nclient.accounts().addOnSuccessListener(accounts -&gt;{\n    Optional&lt;Account&gt; account = accounts.stream().filter(acc -&gt; acc.retailerId() == AMAZON).findFirst();\n    if(account.isPresent()){\n        client.unlink(account.get()).addOnSuccessListener(success -&gt; {\n            //i.e. link another amazon account\n        });\n    }\n});\n</code></pre> <p>To see the full list of supported retailers and their ids, check out the documentation .</p>"},{"location":"how_to_use_alp/#grabbing-orders","title":"Grabbing Orders","text":"<p>When grabbing orders, you can decide to either grab orders for all linked accounts or to grab orders for only a specific retailer. Depending on your use case, you can call the necessary <code>orders</code> function on the <code>AccountLinkingClient</code> instance.</p> <p>The method takes in a success and failure callback.</p> <p>The success callback will be called multiple times during one order retrieving session. The callback will be invoked once for every order that has been found, from the most recent to the oldest order. The callback provides the retailer ID, the retrieved order, the session UUID as well as the number of remaining orders which are expected to be returned.</p> <p>If the linked account hasn\u2019t already been verified, the <code>orders</code> call will try to verify it before retrieving any orders.</p> <p>The failure callback returns an <code>AccountLinkingException</code> as well as the retailer ID for which the failure occurred. If user was logged out since the last <code>verify</code> or <code>orders</code> call or some additional action is required from the user, the failure callback can return an exception with the code <code>VERIFICATION_NEEDED</code>, which means you\u2019ll have to handle it like described in the Verifying Accounts section.</p>"},{"location":"how_to_use_alp/#grabbing-orders-example","title":"Grabbing Orders Example","text":"KotlinJava <pre><code>val client = AccountLinkingClient(context)\n//config the client, or link an account if you haven't linked it already\n\nval allOrders = mutableListOf&lt;ScanResults&gt;()\n\nclient.orders(AMAZON,\n    success = { retailerId: Int, results: ScanResults?, remaining: Int, uuid: String -&gt;\n        if (results != null) {\n            allOrders.add(results)\n        }\n\n        if (remaining == 0) {\n            //process the collected orders\n        }\n    },\n    failure = { retailerId: Int, exception: AccountLinkingException -&gt;\n        if (exception.code == VERIFICATION_NEEDED) {\n            //in this case, the exception.view will be != null, so you can show it in your app\n            //and the user can resolve the needed verification, i.e.:\n            if (exception.view != null) {\n                binding.webViewContainer.addView(exception.view)\n            }\n        }\n    })\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\n//config the client, or link an account if you haven't linked it already\nAccount account = new Account(\n    AMAZON,\n    Credentials.Password(\n        \"amazon_username\",\n        \"amazon_password\"\n    )\n);\n\nList&lt;ScanResults&gt; allResults = new ArrayList&lt;&gt;();\n\nclient.orders(AMAZON, (Integer retailerId, ScanResults results, Integer remaining, String uuid) -&gt;{\n    allResults.add(results);\n    if(remaining == 0){\n        //process the collected orders\n    }\n    return Unit.INSTANCE;\n}, (Integer retailerId, AccountLinkingException exception) -&gt; {\n    if(exception.code() == VERIFICATION_NEEDED){\n        //in this case, the exception.view() will be != null, so you can show it in your app\n        //and the user can resolve the needed verification, i.e.:\n        if(exception.view() != null){\n            binding.webViewContainer.addView(exception.view())\n        }\n    }\n    return Unit.INSTANCE;\n});\n</code></pre> <p>Warning</p> <p>If you call the <code>orders</code> function which collects orders for all your linked accounts, you will have to keep track of which retailers   finished or failed manually to be sure that the <code>orders</code> session is over.</p>"},{"location":"how_to_use_alp/#verifying-accounts-optional","title":"Verifying Accounts (optional)","text":"<p>After you\u2019ve linked an account, you can verify it before retrieving orders. This will ensure that the linked account is valid before you try to retrieve orders. To verify an account, you have to call the <code>verify</code> method of the <code>AccountLinkingClient</code>. The <code>verify</code> method takes in the id of the retailer for which you want to verify the linked account, and then also three callbacks.</p> <p>The first one is a success callback, which will be called if the verification process was successful. The callback returns a boolean value that tells you if your account was verified, as well as a UUID for tracking purposes. If you find any issues while verifying or retrieving orders, you can send us the UUID of the session and we can check the logs to see what happened.</p> <p>The second callback you need to pass in is an error callback, which is called whenever the verification process runs into an issue. It returns an AccountLinkingException , which contains an error code, a UUID of the session, a reference to an underlying exception, and, depending on the error type, a reference to a WebView. It\u2019s possible that while verifying your account, additional actions are needed from the end user, like entering a 2FA code, solving a captcha, or similar. This is recognized by the error code in the returned exception <code>VERIFICATION_NEEDED</code>. In this case, you have to display the returned WebView. For more information, see the example below.</p> <p>The third callback is a preview callback, which will return the <code>WebView</code> which will run the verification session, but only if the <code>BlinkReceiptLinkingSdk.debug</code> property is set to <code>true</code>. This is meant to be used only for debugging purposes.</p>"},{"location":"how_to_use_alp/#verification-example","title":"Verification Example","text":"KotlinJava <pre><code>val client = AccountLinkingClient(context)\n\nval account = Account(\n    AMAZON,\n    Credentials.Password(\n        \"amazon_username\",\n        \"amazon_password\"\n    )\n)\n\nclient.link(account).addOnSuccessListener {\n    client.verify(account.retailerId,\n        success = { success: Boolean, uuid: String -&gt; // grab orders, etc...\n        },\n        failure = { exception -&gt;\n            if (exception.code == VERIFICATION_NEEDED) {\n                //in this case, the exception.view will be != null, so you can show it in your app\n                //and the user can resolve the needed verification, i.e.:\n                if (exception.view != null) {\n                    binding.webViewContainer.addView(exception.view)\n                }\n            }\n        }\n    )\n}\n</code></pre> <pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\n\nAccount account = new Account(\n        AMAZON,\n        Credentials.Password(\n            \"amazon_username\",\n            \"amazon_password\"\n        )\n);\n\nclient.link(account).addOnSuccessListener(success -&gt;{\n    client.verify(account.retailerId(), (Boolean isSuccess, String uuid) -&gt; {\n        //grab orders, etc...\n        return Unit.INSTANCE;\n    }, (AccountLinkingException exception) -&gt; {\n        if (exception.code() == VERIFICATION_NEEDED) {\n            //in this case, the exception.view will be != null, so you can show it in your app\n            //and the user can resolve the needed verification, i.e.:\n            if (exception.view() != null) {\n                binding.webViewContainer.addView(exception.view());\n            }\n        }\n        return Unit.INSTANCE;\n    });\n});\n</code></pre> <p>Do not link verify or order calls to any lifecycle methods, like <code>onCreate</code> or <code>onStart</code>, as this can lead to creating multiple sessions at once and memory leaks.</p>"},{"location":"how_to_use_alp/#closing-the-client","title":"Closing the client","text":"<p>After you\u2019re finished with the client, i.e. you\u2019ve verified the accounts you wanted to verify or retrieved orders, you must call the <code>close</code> method of the <code>AccountLinkingClient</code> to reclaim resources and prevent memory leaks.</p>"},{"location":"how_to_use_alp/#resetting-retailer-history","title":"Resetting retailer history","text":"<p>If you want to clear the history of a specific retailer, you can call the <code>resetHistory</code> and pass in the specific retailer ID. You should do this when you want to link a different account for the same retailer you already had linked, or if you want to retrieve older orders which you had already retrieved before.</p> KotlinJava Reset retailer history<pre><code>val client = AccountLinkingClient(context)\n\nclient.resetHistory(AMAZON).addOnSuccessListener {\n   // e.g. link a different amazon account\n}\n</code></pre> Reset retailer history<pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\n\nclient.resetHistory(AMAZON).addOnSuccessListener(success -&gt; {\n  // e.g. link a different amazon account\n});\n</code></pre> <p>Similarly, you can reset the history for all retailers, by calling the <code>resetHistory</code> method which takes in no parameters.</p> KotlinJava Reset all retailers history<pre><code>val client = AccountLinkingClient(context)\n\nclient.resetHistory().addOnSuccessListener {\n}\n</code></pre> Reset all retailers history<pre><code>AccountLinkingClient client = new AccountLinkingClient(context);\n\nclient.resetHistory().addOnSuccessListener(sucess -&gt; {\n});\n</code></pre>"},{"location":"javadoc/","title":"Javadoc","text":"<ul> <li>BlinkReceiptAccountLinking</li> <li>BlinkReceipt Recognizer</li> <li>BlinkReceipt Core</li> <li>BlinkReceipt Barcode</li> <li>BlinkReceipt Camera</li> <li>BlinkReceipt Camera UI</li> <li>BlinkReceipt Digital</li> <li>BlinkReceipt Earnings</li> </ul>"},{"location":"maven_migration/","title":"Maven migration guide","text":""},{"location":"maven_migration/#effective-from-sep-1-2025","title":"Effective From: Sep 1, 2025","text":"<p>Microblink is moving its Android SDK distribution from a custom Maven repository (Microblink Maven) to Maven Central (Maven Central: Search).</p>"},{"location":"maven_migration/#whats-changing","title":"What\u2019s Changing?","text":""},{"location":"maven_migration/#old-setup-before-migration","title":"Old Setup (Before Migration):","text":"<pre><code>repositories {\n    maven { url \"https://maven.microblink.com\" }\n}\ndependencies {\n    implementation 'com.microblink.blinkreceipt:blinkreceipt-bom:[version]'\n}\n</code></pre>"},{"location":"maven_migration/#new-setup-after-migration","title":"New Setup (After Migration):","text":"<pre><code>repositories {\n    mavenCentral()\n}\ndependencies {\n    implementation 'com.microblink.blinkreceipt:blinkreceipt-bom:[version]'\n}\n</code></pre> <p>\ud83d\udd01 Only the repository source is changing. The SDK package name and usage remain the same. </p>"},{"location":"maven_migration/#step-by-step-migration-instructions","title":"Step-by-Step Migration Instructions","text":""},{"location":"maven_migration/#1-remove-the-custom-microblink-maven-repository","title":"1. Remove the Custom Microblink Maven Repository","text":"<p>In your project\u2019s build.gradle (Project-level or Module-level), remove: <pre><code>maven { url \"https://maven.microblink.com\" }\n</code></pre></p>"},{"location":"maven_migration/#2-ensure-maven-central-is-declared","title":"2. Ensure Maven Central is Declared","text":"<p>If not already present, add this to your repositories block: <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre></p> <p>\u2139\ufe0f If you\u2019re using google() make sure mavenCentral() is included as well. </p>"},{"location":"maven_migration/#3-keep-your-existing-dependency-declaration","title":"3. Keep Your Existing Dependency Declaration","text":"<p>No changes are required to the dependency itself. You can continue using: <pre><code>implementation 'com.microblink.blinkreceipt:blinkreceipt:[version]'\n</code></pre> Replace [version] with the version you need. You can browse available versions here: Maven Central: Search</p>"},{"location":"maven_migration/#post-migration-checklist","title":"Post-Migration Checklist","text":"<ul> <li>Removed the custom Maven Microblink repository</li> <li>Added or verified mavenCentral() is present</li> <li>Synced Gradle and verified no build errors</li> <li>Checked that the correct SDK version is downloaded from Maven Central</li> </ul>"},{"location":"maven_migration/#faq","title":"FAQ","text":""},{"location":"maven_migration/#q-do-i-need-to-change-the-sdk-version-number","title":"Q: Do I need to change the SDK version number?","text":"<ul> <li>A: No, unless you\u2019re upgrading to a newer version. The same artifact and versioning are used.</li> </ul>"},{"location":"maven_migration/#q-what-if-im-using-a-private-or-enterprise-build-system-eg-artifactory","title":"Q: What if I\u2019m using a private or enterprise build system (e.g., Artifactory)?","text":"<ul> <li>A: Ensure your internal repository proxies Maven Central. Contact your DevOps team if needed.</li> </ul>"},{"location":"maven_migration/#q-will-older-versions-be-available-on-maven-central","title":"Q: Will older versions be available on Maven Central?","text":"<ul> <li>A: Only selected versions are hosted. It\u2019s recommended to use the latest version available on Maven Central.</li> </ul>"},{"location":"override_labels_camera_ui/","title":"Camera UI","text":"<p>String resource mapping</p> string key English(Default) Preview <code>recognizer_receipt_edge</code> R\\ne\\nc\\ne\\ni\\np\\nt\\n\\nE\\nd\\ng\\ne <code>scan_characteristics_option_date</code> Date <code>scan_characteristics_option_total</code> Total <code>scan_characteristics_option_merchant</code> Merchant <code>scan_characteristics_option_subtotal</code> Subtotal <code>scan_characteristics_option_taxes</code> Taxes <code>scan_characteristics_option_time</code> Time <code>scan_characteristics_option_store_address</code> Store Address <code>scan_characteristics_option_store_city</code> Store City <code>scan_characteristics_option_store_country</code> Store Country <code>scan_characteristics_option_store_state</code> Store State <code>scan_characteristics_option_store_zip</code> Store Zip <code>scan_characteristics_option_store_phone</code> Store Phone <code>recognizer_camera_long_receipt_add_photos_hint</code> Long receipt? Add Photos. <code>recognizer_camera_initial_instruction</code> Align left and right receipt edge.Long receipt? Take multiple photos <code>recognizer_align_image_hint</code> Start next photo here. <code>recognizer_blurry_image_tooltip</code> Image seems blurry. You cantry again and tap to focus. <code>recognizer_missing_data_tooltip</code> Data missing? You can still hitcheckmark to finish scan <code>recognizer_blurry_image_btn</code> Dismiss <code>recognizer_move_closer_suggestion</code> Move Closer <code>recognizer_move_further_suggestion</code> Move Further <code>confirm</code> confirm <p>You can apply your own translation on each string entry. This can be done by doing the following steps:</p> <ul> <li>Right click on <code>res</code> folder -&gt; Click <code>New</code> -&gt; Click <code>Android Resource File</code><ul> <li></li> </ul> </li> <li>Select Qualifier Local -&gt; Select your desired Language(i.e. \u201cGerman\u201d) -&gt; All Region(or may select a specific region)<ul> <li></li> </ul> <li>Provide string entry translation as desired (i.e. \u201cGerman\u201d language translation). <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n    &lt;!-- You can override the following labels(German) --&gt;\n    &lt;string name=\"recognizer_receipt_edge\"&gt;Q\\nu\\ni\\nt\\nt\\nu\\nn\\ng\\n\\nR\\na\\nn\\nd&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_date\"&gt;Datum&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_total\"&gt;Gesamt&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_merchant\"&gt;H\u00e4ndler&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_subtotal\"&gt;Zwischensumme&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_taxes\"&gt;Steuern&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_time\"&gt;Zeit&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_store_address\"&gt;Adresse des Gesch\u00e4fts&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_store_city\"&gt;Stadt des Gesch\u00e4ft&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_store_country\"&gt;Land des Gesch\u00e4fts&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_store_state\"&gt;Staat des Gesch\u00e4fts&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_store_zip\"&gt;Postleitzahl des Gesch\u00e4fts&lt;/string&gt;\n    &lt;string name=\"scan_characteristics_option_store_phone\"&gt;Telefon des Gesch\u00e4fts&lt;/string&gt;\n\n    &lt;string name=\"recognizer_camera_long_receipt_add_photos_hint\"&gt;Lange Quittung? Fotos hinzuf\u00fcgen.&lt;/string&gt;\n    &lt;string name=\"recognizer_camera_initial_instruction\"&gt;Richten Sie die linke und rechte Bonkante aus.\\nLange Quittung? Machen Sie mehrere Fotos&lt;/string&gt;\n    &lt;string name=\"recognizer_align_image_hint\"&gt;Beginnen Sie hier mit dem n\u00e4chsten Foto.&lt;/string&gt;\n    &lt;string name=\"recognizer_blurry_image_tooltip\"&gt;Das Bild scheint verschwommen zu sein. Du kannst\\nVersuchen Sie es erneut und tippen Sie, um zu fokussieren.&lt;/string&gt;\n    &lt;string name=\"recognizer_missing_data_tooltip\"&gt;Daten fehlen? Du kannst immer noch zuschlagen\\nMarkieren Sie das H\u00e4kchen, um den Scanvorgang abzuschlie\u00dfen&lt;/string&gt;\n    &lt;string name=\"recognizer_blurry_image_btn\"&gt;Zur\u00fcckweisen&lt;/string&gt;\n    &lt;string name=\"recognizer_move_closer_suggestion\"&gt;Komm n\u00e4her&lt;/string&gt;\n    &lt;string name=\"recognizer_move_further_suggestion\"&gt;Bewegen Sie sich weiter&lt;/string&gt;\n    &lt;string name=\"confirm\"&gt;best\u00e4tigen&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre></li> <p>For more details about Android App Resource Localization, you may look at Android\u2019s official documentation Localize your app.</p>"},{"location":"supported_retailers/","title":"Supported Retailers","text":"Retailer Name Country Acme Markets US Albertsons US AliExpress UK Amazon US | UK | CA | FR | ES | DE | AU ASDA UK BestBuy US BJ\u2019s Wholesale Club US Carrefour ES Chewy US Coles AU Costco Wholesale Corp. US | CA CVS US Dick\u2019s Sporting Goods US Dollar General US Dollar Tree US Domino\u2019s Pizza US DoorDash US Family Dollar US Food 4 Less US Food Lion US Fred Meyer US GAP US GrubHub US Harris Teeter US Home Depot US Instacart US Jewel Osco US Kroger US Lowe\u2019s Home Improvement US Meijer US PC Express CA Postmates US Publix Super Markets US Ralph\u2019s US Safeway US Sainsbury\u2019s UK Sam\u2019s Club US Seamless US Sephora US SHEIN US | UK | ES Shipt US ShopRite US Sprouts Farmers Market US Starbucks US Taco Bell US Target US Temu UK Tesco Stores UK Uber Eats US | UK Ulta US Vons US Walgreens US Walmart US | CA Wegmans Food Markets US Woolworths AU"},{"location":"workmanager_integration/","title":"WorkManager Integration","text":"<p>This is a guide on how we suggest apps with custom WorkManager configuration and initialization to properly integrate with our SDK.</p> <p>If your app provides custom WorkManager configuration and initialization, follow these steps:</p>"},{"location":"workmanager_integration/#first-ensure-that-androidxstartup-framework-is-added-in-your-gradle-dependencies","title":"First, ensure that <code>androidx.startup</code> framework is added in your gradle dependencies:","text":"<pre><code>depdendencies {\n    implementation(\"androidx.startup:startup-runtime:X.Y.Z\")\n}\n</code></pre>"},{"location":"workmanager_integration/#add-the-following-entries-under-androidmanifestxml","title":"Add the following entries under <code>AndroidManifest.xml</code>:","text":"<pre><code>&lt;!-- AndroidManifest.xml --&gt;\n&lt;application&gt;\n    &lt;!-- ... --&gt;\n    &lt;provider\n            android:name=\"androidx.startup.InitializationProvider\"\n            android:authorities=\"${applicationId}.androidx-startup\"\n            android:exported=\"false\"\n            tools:node=\"merge\"&gt;\n            &lt;!-- Remove BlinkReceipt SDK's default initializer --&gt;\n            &lt;meta-data\n                android:name=\"com.microblink.internal.ReceiptSdkInitializer\" \n                android:value=\"androidx.startup\"\n                tools:node=\"remove\" /&gt;\n            &lt;!-- Remove WorkManager Initializer --&gt;\n            &lt;meta-data\n                android:name=\"androidx.work.WorkManagerInitializer\"\n                android:value=\"androidx.startup\"\n                tools:node=\"remove\" /&gt;\n            &lt;!-- Remove BlinkReceipt's Barcode Detector initializer --&gt;\n            &lt;meta-data\n                android:name=\"com.microblink.internal.BarcodeDetectorInitializer\"\n                android:value=\"androidx.startup\"\n                tools:node=\"remove\"/&gt;\n            &lt;!-- Introduce your custom Initializer --&gt;\n            &lt;meta-data\n                android:name=\"com.custom.app.AppInitializer\"\n                android:value=\"androidx.startup\"/&gt;\n    &lt;/provider&gt;\n&lt;/application&gt;\n</code></pre>"},{"location":"workmanager_integration/#then-define-the-custom-initializer-this-is-where-the-custom-workmanager-configuration-and-initialization-takes-place","title":"Then, define the custom Initializer. This is where the custom WorkManager configuration and initialization takes place.","text":"<pre><code>public class AppInitializer: Initializer&lt;Unit&gt; {\n\n    override fun create(context: Context) {\n        val configuration = Configuration.Builder()\n            .setDefaultProcessName(\"com.custom.app:custom-app-process\")\n            // Other Client-specific configuration(s)\n            .build()\n        WorkManager.initialize(context, configuration)\n        return\n    }\n\n    override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;?&gt;?&gt; = emptyList()\n}\n</code></pre>"},{"location":"workmanager_integration/#finally-manually-initialize-the-sdk-from-the-application-class","title":"Finally, manually initialize the SDK from the Application class:","text":"<p><pre><code>@Override\npublic void onCreate() {\n    super.onCreate();\n\n    BlinkReceiptSdk.initialize( context );\n}\n</code></pre> - This will ensure that the your app\u2019s WorkManager configuration and initialization will supersede and will be used across both client app and SDK\u2019s internal logic.</p>"},{"location":"receipts/camera_ui_jetpack_compose_integration_guide/","title":"Camera UI + Jetpack Compose Integration Guide","text":"<p>This guide provides comprehensive instructions for integrating the BlinkReceipt Camera UI into a Jetpack Compose-based Android application. It covers two primary integration strategies: utilizing the <code>RecognizerView</code> for a custom scanning UI and implementing the out-of-the-box <code>Blink Camera Ui</code> for a complete, pre-built camera experience.</p>"},{"location":"receipts/camera_ui_jetpack_compose_integration_guide/#custom-scan-using-recognizerview","title":"Custom Scan using <code>RecognizerView</code>","text":"<p>To integrate the <code>RecognizerView</code> with Jetpack Compose, use the <code>AndroidView</code> composable. This allows you to embed a traditional Android View within your Compose UI. It\u2019s important to manage the lifecycle of the <code>RecognizerView</code> by creating it in the <code>factory</code> lambda of <code>AndroidView</code> and handling its lifecycle events.</p> <p>Here is an example of how to set up the <code>RecognizerView</code> in a Composable function: <pre><code>@Composable\nfun RecognizerViewComposable(\n    modifier: Modifier,\n    // ...\n) {\n  val context = LocalContext.current\n  val lifecycleOwner = LocalLifecycleOwner.current\n\n  // Use remember to prevent the RecognizerView from being re-created on every recomposition.\n  val recognizerView = remember {\n      RecognizerView(context).apply {\n        setMeteringAreas(arrayOf(RectF(0f, 0f, 1f, 1f)), true)\n        initialOrientation = Orientation.ORIENTATION_PORTRAIT\n        aspectMode = CameraAspectMode.ASPECT_FILL\n\n        // Observe Recognizer Callback\n        recognizerCallback(object: CameraRecognizerCallback {\n          // ...\n        })\n\n        // Initialize with ScanOptions\n        initialize(\n          ScanOptions\n            .newBuilder()\n            // ...\n            .build()\n        )\n\n        // Attach Lifecycle Owner\n        lifecycle(lifecycleOwner)\n      }\n  }\n\n  AndroidView(\n      factory = { recognizerView },\n      modifier = modifier,\n      onRelease = { view -&gt;\n          view.terminate()\n      }\n  )\n}\n</code></pre></p>"},{"location":"receipts/camera_ui_jetpack_compose_integration_guide/#out-of-the-box-camera-experience-using-blink-camera-ui","title":"Out-of-the-box Camera Experience using Blink Camera UI","text":"<p>There are two primary approaches to integrate the pre-built camera experience: embedding the <code>CameraRecognizerFragment</code> directly into your composable for a tightly integrated UI, or launching it as a separate activity using a <code>CameraRecognizerContract</code> for a more decoupled flow.</p>"},{"location":"receipts/camera_ui_jetpack_compose_integration_guide/#1-embed-camerarecognizerfragment-using-androidfragment","title":"1. Embed <code>CameraRecognizerFragment</code> using <code>AndroidFragment</code>","text":"<p>This method involves embedding the <code>CameraRecognizerFragment</code> within a composable using the <code>AndroidFragment</code> composable from the <code>androidx.fragment:fragment-compose</code> library. This is an excellent choice if your app already utilizes a Fragment-based architecture or if you want to place the camera view as a component within a larger composable screen. This approach allows you to manage the camera\u2019s lifecycle and handle results directly within the composable\u2019s context.</p> <p><pre><code>// build.gradle\nimplementation \"androidx.fragment:fragment-compose:1.8.9\"\n</code></pre> <pre><code>import androidx.fragment.app.FragmentActivity\n\nclass MainActivity : FragmentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            OobCameraContent(\n                modifier = Modifier,\n                onScanResults = { results: CameraRecognizerResults -&gt;\n                    // Process CameraRecognizerResults here...\n                }\n            )\n        }\n    }\n}\n</code></pre> <pre><code>@Composable\ninternal fun CameraRecognizerContent(\n    modifier: Modifier,\n    onScanResults: ((CameraRecognizerResults) -&gt; Unit),\n) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n\n    AndroidFragment&lt;CameraRecognizerFragment&gt;(\n        modifier = modifier.fillMaxSize(),\n        arguments = bundleOf(\n            CameraRecognizerFragment.OPTIONS to ScanOptions\n                .newBuilder()\n                // Define your own ScanOptions configuration here...\n                .build(),\n            CameraRecognizerFragment.CAMERA_CHARACTERISTICS to CameraCharacteristics.Builder()\n                .scanCharacteristics(\n                    ScanCharacteristics.Builder()\n                        // Define your own ScanCharacteristics configuration here...\n                        .build()\n                )\n                .tooltipCharacteristics(\n                    TooltipCharacteristics.Builder()\n                        // Define your own TooltipCharacteristics configuration here...\n                        .build()\n                )\n                // Define other CameraCharacteristics configuration here...\n                .build(),\n        ),\n    ) { fragment -&gt;\n        fragment.parentFragmentManager\n            .setFragmentResultListener(\n                CameraRecognizerFragment.SCAN_SESSION_RESULTS_KEY,\n                lifecycleOwner,\n            ) { _, bundle -&gt;\n                bundle.parcelable&lt;CameraRecognizerResults&gt;(CameraRecognizerFragment.SCAN_RESULTS_KEY)\n                    ?.let { results -&gt;\n                        // Retrieve CameraRecognizerResults here...\n                        onScanResults(results)\n                    }\n            }\n    }\n}\n</code></pre></p>"},{"location":"receipts/camera_ui_jetpack_compose_integration_guide/#2-launch-as-an-activity-using-camerarecognizercontract","title":"2. Launch as an Activity using <code>CameraRecognizerContract</code>","text":"<p>This approach leverages the modern Android Activity Result APIs. By using <code>rememberLauncherForActivityResult</code> with the <code>CameraRecognizerContract</code>, you can launch the camera recognizer as a separate activity and receive the results back in a callback. This method is ideal for a more decoupled architecture where the camera scanning process is a distinct step in a user flow. It simplifies state management as the camera UI is entirely separate from your calling composable.</p> <pre><code>@Composable\ninternal fun CameraRecognizerContent(\n    modifier: Modifier,\n    onScanResults: ((CameraRecognizerResults) -&gt; Unit),\n) {\n    val launcher = rememberLauncherForActivityResult(\n        CameraRecognizerContract()\n    ) { results: CameraRecognizerResults -&gt;\n        onScanResults(results)\n    }\n\n    // Launch the camera recognizer when this composable enters the composition\n    LaunchedEffect(Unit) {\n        launcher.launch(\n            CameraRecognizerOptions.Builder()\n                .options(\n                    ScanOptions\n                        .newBuilder()\n                        // Define your own ScanOptions configuration here...\n                        .build()\n                )\n                .characteristics(\n                    CameraCharacteristics.Builder()\n                        // Define other CameraCharacteristics configuration here...\n                        .scanCharacteristics(\n                            ScanCharacteristics.Builder()\n                                // Define your own ScanCharacteristics configuration here...\n                                .build()\n                        )\n                        .tooltipCharacteristics(\n                            TooltipCharacteristics.Builder()\n                                // Define your own TooltipCharacteristics configuration here...\n                                .build()\n                        )\n                        .build()\n                )\n                .build()\n        )\n    }\n}\n</code></pre>"},{"location":"receipts/barcode/updating_your_barcode_scanning_integration/","title":"Updating Your Barcode Scanning Integration (v1.9.5+)","text":"<p>Who is this guide for? This guide is for developers using BlinkReceipt SDK 1.9.5 or newer, we already migrated to Google MLKit Barcode.  If you are implementing barcode scanning for the first time or upgrading from an older version, please read this carefully.</p> <p>Due to a migration to Google\u2019s MLKit for barcode scanning in SDK v1.9.5, there is a fundamental behavioral change in how RecognizerView  handles a scanning session. This guide explains the change and how to adapt your implementation.</p>"},{"location":"receipts/barcode/updating_your_barcode_scanning_integration/#tldr-the-quick-summary","title":"TL;DR: The Quick Summary","text":"<p>The barcode scanner now automatically pauses after the very first result it produces, which is often an empty result right after the camera starts.</p> <p>Your Action: You must now check for empty results and explicitly call recognizerView.resumeScanning(true) when you are ready to scan again.</p>"},{"location":"receipts/barcode/updating_your_barcode_scanning_integration/#understanding-the-change","title":"Understanding the Change","text":"<p>To build a robust implementation, it\u2019s important to understand what is happening behind the scenes.</p> <ul> <li> <p>Cause: We now use Google\u2019s MLKit, which begins analyzing frames from the camera immediately upon initialization.</p> </li> <li> <p>Effect: As soon as RecognizerView  starts, it analyzes the camera view. Because the user hasn\u2019t yet aimed at a barcode, it quickly produces a result: \u201cno barcodes found.\u201d</p> </li> <li> <p>The Problem: The SDK is designed to pause the scanning session after every result to allow your app to process it.  This means the initial \u201cempty\u201d result immediately PAUSES the scanner.  By the time the user aims their camera at a barcode, the RecognizerView  is in a PAUSED state and won\u2019t detect anything further.</p> </li> </ul>"},{"location":"receipts/barcode/updating_your_barcode_scanning_integration/#how-to-update-your-implementation","title":"How to Update Your Implementation","text":"<p>You must update your code to handle this \u201cpause on result\u201d behavior. The correct approach depends on your app\u2019s use case.</p>"},{"location":"receipts/barcode/updating_your_barcode_scanning_integration/#scenario-a-scan-a-single-barcode","title":"Scenario A: Scan a Single Barcode","text":"<p>Use this if you want the user to scan one barcode, get the result, and then stop.</p> <p>In this scenario, you should ignore the initial empty result and only act when a valid barcode is found. You do not need to resume scanning automatically.</p> <pre><code>val recognizerView = findViewById&lt;RecognizerView&gt;(R.id.recognizerView)\n\nrecognizerView.metadataCallbacks(\n    MetadataCallbacks().apply {\n        recognizerCallback { results: RecognizerResults -&gt;\n            // This callback provides the actual scan data.\n            // First, check if the result is valid and not the initial empty one.\n            if (results.barcodes().isNotEmpty()) {\n                // SUCCESS: A barcode was found!\n                // The scanner is now PAUSED automatically.\n\n                // Get your barcode data and Process the result (e.g., close this screen, show data)\n                // You DO NOT need to call resumeScanning() here if you're done.\n                // showResultAndFinish(barcodeText) \n            }\n            // If the result is empty, do nothing and let the scanner continue.\n            // The resumeScanning() call in scanResultListener will handle restarting it.\n        }\n\n        failedDetectionCallback {\n            // Optional: Handle cases where a barcode-like object was detected but failed to be parsed.\n            // You can provide user feedback here, like \"Hold the camera steady.\"\n        }\n    }\n)\n\n// This listener is a generic callback that fires whenever a result is processed.\n// It's the perfect place to manage the scanning lifecycle.\nrecognizerView.scanResultListener {\n    // Each time your app receives a result (even an empty one), the scanning session pauses.\n    // To ensure the user can scan, we must resume scanning if no valid barcode has been found yet.\n    // We pass `true` to reset the internal state for the next scan.\n    recognizerView.resumeScanning(true)\n})\n</code></pre>"},{"location":"receipts/barcode/updating_your_barcode_scanning_integration/#scenario-b-continuous-scanning","title":"Scenario B: Continuous Scanning","text":"<p>Use this for applications like inventory management, where a user might scan multiple barcodes one after another without closing the scanner.</p> <p>The logic is similar to the single-scan scenario, but you will call recognizerView.resumeScanning(true)  after you have successfully processed a barcode.</p> <pre><code>val recognizerView = findViewById&lt;RecognizerView&gt;(R.id.recognizerView)\n\nrecognizerView.metadataCallbacks(\n    MetadataCallbacks().apply {\n        recognizerCallback { results: RecognizerResults -&gt;\n            // Check if a valid barcode was found.\n            if (results.barcodeResults().isNotEmpty()) {\n                // SUCCESS: A barcode was found!\n                // The scanner is now PAUSED automatically.\n\n                // 1. Add the result to your list or process it.\n                // 2. Provide feedback to the user (e.g., a \"beep\" sound or vibration).\n                // 3. The scanner is now PAUSED. The scanResultListener below will resume it.\n            }\n        }\n    }\n)\n\nrecognizerView.scanResultListener {\n    // For continuous scanning, we *always* want to resume after any result.\n    // This allows the user to immediately point the camera at the next barcode.\n    // Consider adding a small delay here if you want to prevent accidental double-scans.\n    recognizerView.resumeScanning(true)\n})\n</code></pre>"},{"location":"receipts/barcode/updating_your_barcode_scanning_integration/#best-practices","title":"Best Practices","text":"<ul> <li>Provide User Feedback: Don\u2019t leave the user guessing. When a barcode is successfully scanned, provide immediate feedback like a sound, vibration, or a brief animation on the screen.</li> <li>Handle Empty States: In your recognizerCallback, always check <code>results.barcodes().isNotEmpty()</code> before trying to access the data to avoid crashes.</li> <li>Manual Rescan Button (Optional): For some UIs, it\u2019s helpful to add a button that allows the user to manually trigger a new scan. This gives them more control.</li> </ul> <pre><code>val resumeBtn = findViewById&lt;Button&gt;(R.id.resumeBtn)\n\nresumeBtn.setOnClickListener {\n    // The 'true' parameter resets the recognizer state, which is recommended.\n    recognizerView.resumeScanning(true)\n}\n</code></pre>"},{"location":"receipts/image/getting_started_image/","title":"Getting started image","text":"<p>The Recognizer SDK enables you to easily scan digital and physical receipts.</p>"},{"location":"receipts/image/getting_started_image/#integration","title":"Integration","text":"<ol> <li>Add the following maven repository to your build.gradle or settings.gradle, depending on your implementation:</li> </ol> KotlinGroovy <pre><code> repositories {\n   maven { url = uri(\"https://maven.microblink.com\") }\n }\n</code></pre> <pre><code> repositories {\n   maven { url \"https://maven.microblink.com\" }\n }\n</code></pre> <ol> <li>Add the following to your dependency section in your app <code>build.gradle</code>.</li> </ol> KotlinGroovy <pre><code>dependencies {\n    implementation(platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\"))\n\n    implementation(\"com.microblink.blinkreceipt:blinkreceipt-recognizer\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\")\n\n    implementation \"com.microblink.blinkreceipt:blinkreceipt-recognizer\"\n}\n</code></pre>"},{"location":"receipts/image/getting_started_image/#setting-your-license-keys","title":"Setting your license keys","text":"<p>There are two ways you can set the license keys for the Account Linking SDK.</p>"},{"location":"receipts/image/getting_started_image/#android-manifest","title":"Android Manifest","text":"<p>In your <code>AndroidManifest.xml</code> file, create the following <code>meta-data</code> tags, and insert your keys under the <code>android:value</code> attribute:</p> <pre><code>&lt;meta-data\n    android:name=\"com.microblink.LicenseKey\"\n    android:value=\"\"\n/&gt;\n\n&lt;meta-data\n    android:name=\"com.microblink.ProductIntelligence\"\n    android:value=\"\"\n/&gt;\n</code></pre> <p>Both the values for <code>com.microblink.LicenseKey</code> and <code>com.microblink.ProductIntelligence</code> can be obtained by emailing blinkreceipt@microblink.com.</p>"},{"location":"receipts/image/getting_started_image/#programmatically","title":"Programmatically","text":"<p>If you want to set your keys programmatically, you can do so by setting them on the appropriate <code>BlinkReceiptSdk</code> fields in your application class in the <code>onCreate</code> method:</p> Kotlin <pre><code>BlinkReceiptSdk.productIntelligenceKey(\"product_intelligence_license_key\")\n</code></pre>"},{"location":"receipts/image/getting_started_image/#initializing-the-sdk","title":"Initializing the SDK","text":"<p>Before you can use the SDK it needs to be initialized. The best way to do this is to call the following function in your application class in the <code>onCreate</code> method:</p> Kotlin <pre><code>BlinkReceiptSdk.initialize(this, object : InitializeCallback {\n    override fun onComplete() {}\n\n        override fun onException(exception: Throwable) {}\n\n    })\n</code></pre> <p>That\u2019s it! You\u2019re all set up to use the Recognizer SDK. Check out the next chapter for more information on how to use the SDK.</p>"},{"location":"receipts/image/how_to_use_image/","title":"How to use image","text":"<p>The main and only entry point to perform Scan Receipt Image using Direct API is the <code>ImageClient</code> class. You can instantiate one by passing an android context to its constructor:</p> Kotlin <pre><code>val client = ImageClient(context)\n</code></pre> Java <pre><code>ImageClient client = new ImageClient(context);\n</code></pre>"},{"location":"receipts/image/how_to_use_image/#recognize-receipt-image-using-direct-api","title":"Recognize Receipt Image using Direct API","text":"<p>You can scan and process a single or multiple Bitmap image(s). Additionally, you can also customize scan option configuration with <code>ScanOptions.Builder</code>.</p> Kotlin <pre><code>val receiptImagesToProcess = arrayOf&lt;Bitmap&gt;(\n    // Bitmap image(s)\n)\nval scanOptions = ScanOptions.newBuilder().build()\n\nclient.recognize(\n    scanOptions,\n    object : RecognizerCallback {\n        override fun onRecognizerResultsChanged(result: RecognizerResult) {\n            // Process Direct API Success Results.\n        }\n\n        override fun onRecognizerException(e: Throwable) {\n            // Handle Direct API error.\n        }\n\n        override fun onRecognizerDone(results: ScanResults, media: Media) {\n            // Observe Direct API Results Changes while Direct API is processing the results.\n        }\n    },\n    *receiptImagesToProcess\n)\n</code></pre> Java <pre><code>Bitmap[] receiptImagesToProcess = new Bitmap[]{\n    // Bitmap image(s)\n};\nScanOptions scanOptions = ScanOptions.newBuilder().build()\n\nclient.recognize(\n    scanOptions, \n    new RecognizerCallback() {\n        @Override\n        public void onRecognizerDone(@NonNull ScanResults scanResults, @NonNull Media media) {\n            // Process Direct API Success Results.\n        }\n\n        @Override\n        public void onRecognizerException(@NonNull Throwable throwable) {\n            // Handle Direct API error.\n        }\n\n        @Override\n        public void onRecognizerResultsChanged(@NonNull RecognizerResult recognizerResult) {\n            // Observe Direct API Results Changes while Direct API is processing the results.\n        }\n    }, \n    receiptImagesToProcess\n);\n</code></pre>"},{"location":"receipts/pdf/configuring_client_pdf/","title":"Configuring the Client","text":"<p>The main and only entry point to scan a PDF is the <code>PdfClient</code> class. You can instantiate one by passing an android context to its constructor:</p> KotlinJava <pre><code>val client = PdfClient(context)\n</code></pre> <pre><code>PdfClient client = new PdfClient(context);\n</code></pre> <p>There are also some more options for configuring the client.</p>"},{"location":"receipts/pdf/configuring_client_pdf/#country-code","title":"Country Code","text":"<p>The <code>countryCode</code> property specifies the code of the country in which the pdf scanning client is used. Setting it correctly improves lookup results for the returned products. You can specify this with the <code>countryCode</code> property on the <code>PdfClient</code> instance, i.e.:</p> KotlinJava <pre><code>val client = PdfClient(context)\n\nclient.countryCode = \"US\"\n</code></pre> <pre><code>PdfClient client = new PdfClient(context);\n\nclient.countryCode(\"US\");\n</code></pre> <p>By default, it is set to <code>\"US\"</code>.</p>"},{"location":"receipts/pdf/configuring_client_pdf/#filter-sensitive-data","title":"Filter Sensitive Data","text":"<p>The <code>filterSensitiveData</code> property specifies the code of the country in which the pdf scanning client is used. Setting it correctly improves lookup results for the returned products. You can specify this with the <code>filterSensitiveData</code> property on the <code>PdfClient</code> instance, i.e.:</p> Kotlin <pre><code>val client = PdfClient(context)\n\nclient.filterSensitiveData = true\n</code></pre> Java <pre><code>PdfClient client = new PdfClient(context);\n\nclient.filterSensitiveData(true);\n</code></pre> <p>By default, it is set to <code>false</code>.</p>"},{"location":"receipts/pdf/configuring_client_pdf/#return-sub-products","title":"Return Sub Products","text":"<p>The <code>returnSubProducts</code> property specifies sub products will be returned. You can specify this with the <code>returnSubProducts</code> property on the <code>PdfClient</code> instance, i.e.:</p> Kotlin <pre><code>val client = PdfClient(context)\n\nclient.returnSubProducts = true\n</code></pre> Java <pre><code>PdfClient client = new PdfClient(context);\n\nclient.returnSubProducts(true);\n</code></pre> <p>By default, it is set to <code>false</code>.</p>"},{"location":"receipts/pdf/configuring_client_pdf/#return-voided-products","title":"Return Voided Products","text":"<p>The <code>returnVoidedProducts</code> property specifies if voided products will be returned. You can specify this with the <code>returnVoidedProducts</code> property on the <code>PdfClient</code> instance, i.e.:</p> Kotlin <pre><code>val client = PdfClient(context)\n\nclient.returnVoidedProducts = true\n</code></pre> Java <pre><code>PdfClient client = new PdfClient(context);\n\nclient.returnVoidedProducts(true);\n</code></pre> <p>By default, it is set to <code>false</code>.</p>"},{"location":"receipts/pdf/configuring_client_pdf/#lifecycle-observer","title":"Lifecycle Observer","text":"<p>Android Lifecycle Observer is a part of the Android Architecture Components introduced by Google. It is used to monitor and respond to lifecycle events of Android components, such as activities and fragments. The Android Lifecycle Observer is particularly useful for managing tasks that should be performed at specific points in an Android component\u2019s lifecycle. Its recommended to attach a lifecycle so the internal resource will be released.</p> Kotlin <pre><code>client = PdfClient(applicationContext).also {\n    lifecycle.addObserver(it)\n}\n</code></pre>"},{"location":"receipts/pdf/getting_started_pdf/","title":"Getting Started","text":"<p>The Recognizer SDK enables you to easily scan digital and physical receipts.</p>"},{"location":"receipts/pdf/getting_started_pdf/#integration","title":"Integration","text":"<ol> <li>Add the following maven repository to your build.gradle or settings.gradle, depending on your implementation:</li> </ol> KotlinGroovy <pre><code> repositories {\n   maven { url = uri(\"https://maven.microblink.com\") }\n }\n</code></pre> <pre><code> repositories {\n   maven { url \"https://maven.microblink.com\" }\n }\n</code></pre> <ol> <li>Add the following to your dependency section in your app <code>build.gradle</code>.</li> </ol> KotlinGroovy <pre><code>dependencies {\n    implementation(platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\"))\n\n    implementation(\"com.microblink.blinkreceipt:blinkreceipt-recognizer\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation platform(\"com.microblink.blinkreceipt:blinkreceipt-bom:1.9.13\")\n\n    implementation \"com.microblink.blinkreceipt:blinkreceipt-recognizer\"\n}\n</code></pre>"},{"location":"receipts/pdf/getting_started_pdf/#setting-your-license-keys","title":"Setting your license keys","text":"<p>There are two ways you can set the license keys for the Account Linking SDK.</p>"},{"location":"receipts/pdf/getting_started_pdf/#android-manifest","title":"Android Manifest","text":"<p>In your <code>AndroidManifest.xml</code> file, create the following <code>meta-data</code> tags, and insert your keys under the <code>android:value</code> attribute:</p> <pre><code>&lt;meta-data\n    android:name=\"com.microblink.LicenseKey\"\n    android:value=\"\"\n/&gt;\n\n&lt;meta-data\n    android:name=\"com.microblink.ProductIntelligence\"\n    android:value=\"\"\n/&gt;\n</code></pre> <p>Both the values for <code>com.microblink.LicenseKey</code> and <code>com.microblink.ProductIntelligence</code> can be obtained by emailing blinkreceipt@microblink.com.</p>"},{"location":"receipts/pdf/getting_started_pdf/#programmatically","title":"Programmatically","text":"<p>If you want to set your keys programmatically, you can do so by setting them on the appropriate <code>BlinkReceiptSdk</code> fields in your application class in the <code>onCreate</code> method:</p> Kotlin <pre><code>BlinkReceiptSdk.productIntelligenceKey(\"product_intelligence_license_key\")\n</code></pre>"},{"location":"receipts/pdf/getting_started_pdf/#initializing-the-sdk","title":"Initializing the SDK","text":"<p>Before you can use the SDK it needs to be initialized. The best way to do this is to call the following function in your application class in the <code>onCreate</code> method:</p> Kotlin <pre><code>BlinkReceiptSdk.initialize(this, object : InitializeCallback {\n    override fun onComplete() {}\n\n        override fun onException(exception: Throwable) {}\n\n    })\n</code></pre> <p>That\u2019s it! You\u2019re all set up to use the Recognizer SDK. Check out the next chapter for more information on how to use the SDK.</p>"},{"location":"receipts/pdf/how_to_use_pdf/","title":"How to use","text":"<p>Before you can start scanning PDFs, you have to create an instance of the <code>PdfClient</code>.</p> Kotlin <pre><code>client = PdfClient(applicationContext).also {\n    val options: ScanOptions = ScanOptions.newBuilder().build()\n\n    it.countryCode = options.countryCode()\n\n    it.filterSensitiveData = options.filterSensitiveData()\n\n    it.returnSubProducts = options.returnSubProducts()\n\n    it.returnVoidedProducts = options.returnVoidedProducts()\n\n    lifecycle.addObserver(it)\n}\n</code></pre> <p>Warning</p> <p>If you don\u2019t add a lifecycle observer, you will be responsible for releasing the <code>PdfClient</code> resources.</p>"},{"location":"receipts/pdf/how_to_use_pdf/#recognize-pdf","title":"Recognize PDF","text":"<p>You can identify a PDF document by providing it as a Uri, File, or ParcelFileDescriptor input. The process of recognizing text within the PDF is performed asynchronously, and the results are delivered through the Google Task framework.</p> <p>When recognizing text in a PDF document, you might use ParcelFileDescriptor to efficiently open and read the PDF file, feeding it to the OCR (Optical Character Recognition) engine asynchronously. The Google Task framework is well-suited for handling such asynchronous tasks and delivering results when the OCR process is complete.</p> Kotlin <pre><code>client.recognize(uri).addOnSuccessListener(this) {\n    //Handle Results\n}.addOnFailureListener {\n    //Handle failure\n}\n</code></pre>"}]}